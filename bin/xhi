#!/usr/bin/node
/* vim: set ft=javascript: */
/*
 * Purpose   : Run hi_score lifecycle tools
 * Example   : See xhi help
 * Author    : Michael S. Mikowski - mike.mikowski@gmail.com
 *
*/
/*jslint node : true */
/*global Promise */
// == BEGIN SCRIPT xhi - the hi_score cli life-stage tool =============
  // == BEGIN MODULE SCOPE VARIABLES ==================================
  'use strict';
  var
    // Import capabilities
    // TODO not used: EventEmitter = require( 'events' ).EventEmitter,
    childProcObj = require( 'child_process' ),
    fsObj        = require( 'fs'            ),
    pathObj      = require( 'path'          ),
    utilObj      = require( 'util'          ),
    promiseObj   = Promise,

    // execFn       = childProcObj.exec,
    makeSpawnObj = childProcObj.spawn,

    // Convert to promises using promisfy
    promisifyFn   = utilObj.promisify,
    makeStatProm  = promisifyFn( fsObj.stat ),

    // Assign nodejs builtins
    // eventObj      = new EventEmitter(),
    fqAppFilename = __filename,
    fqBinDirname  = __dirname,

    // Get environment values
    appName       = pathObj.basename( fqAppFilename, '.js' ),
    argList       = process.argv,
    fqOrigDirname = process.cwd(), // or pathObj.resolve()
    padName       = '      ' + appName,
    versList      = process.versions.node.split('.'),

    // Set paths
    fqProjDirname   = pathObj.dirname( fqBinDirname ),

    fqGitDirname    = fqProjDirname   + '/.git',
    fqLibDirname    = fqProjDirname   + '/lib',
    fqModuleDirname = fqProjDirname   + '/node_modules',
    fqPkgFilename   = fqProjDirname   + '/package.json',

    // Set minimum Node verion number and init empty map
    minVersionInt  = 8,
    binPathMap     = {},

    // Set convenience vars
    __0 = 0,
    __1 = 1,

    // Declare curried functions
    abortFn, exitFn, logFn, warnFn,

    // Declare config data
    fqHookFilename,  pkgMatrix,    setupMatrix,
    commandTable,

    // Declare after-install-variables
    LineReader,    applyPatchFn,  exeCpeFn,
    flowObj,       mkdirpFn,      ncpFn,
    rmDirFn,       whichFn,       makeWhichProm,
    makeRmDirProm
    ;
  // == . END MODULE SCOPE VARIABLES ==================================

  // == BEGIN UTILITY METHODS =========================================
  // BEGIN utility /makeRightPadStr/
  function makeRightPadStr ( arg_str, arg_count ) {
    var
      delta_count = arg_count - arg_str.length,
      delta_list  = []
      ;

    delta_list.length = delta_count > 0 ? delta_count : 0;
    return arg_str + delta_list.join(' ');
  }
  // . END utility /makeRightPadStr/

  // BEGIN utility /_outFn/
  // Purpose: provides abortFn, exitFn, logFn, and warnFn
  function _outFn() {
    var
      ctx_obj    = this || {},
      method_str = ctx_obj.method_str || 'log',
      prompt_str = ctx_obj.prompt_str || appName + '-info> ',
      arg_list   = Array.from( arguments )
      ;

    if ( arg_list.length > 0 ) {
      arg_list.unshift( prompt_str );
      console[ method_str ].apply( null, arg_list );
    }
    if ( ctx_obj.cd_name ) {
      process.chdir( ctx_obj.cd_name );
    }
    if ( ctx_obj.do_abort ) { process.exit( 1 ); }
    if ( ctx_obj.do_exit  ) { process.exit( 0 ); }
  }
  abortFn = _outFn.bind({
    cd_name      : fqOrigDirname,
    do_abort     : true,
    method_str : 'warn',
    prompt_str : appName + '-abort> '
  });
  exitFn = _outFn.bind({
    cd_name   : fqOrigDirname,
    do_exit    : true,
    prompt_str : appName + '-exit> '
  });
  logFn   = _outFn.bind({});
  warnFn  = _outFn.bind({
    method_str : 'warn',
    prompt_str : appName + '-warn> '
  });
  // . END utility /_outFn/

  // BEGIN utility /makeCommandTable/
  function makeCommandTable ( raw_table ) {
    var
      head_row    = raw_table.shift(),
      solve_table = []
      ;

    raw_table.forEach( function ( src_list, row_idx ) {
      var row_id = String( row_idx ), row_map;
      if ( row_id.length < 2 ) { row_id = '0' + row_id; }
      row_map = { id : row_id, idx : row_idx };
      head_row.forEach( function ( head_val, head_idx ) {
        row_map[ head_val ] = src_list[ head_idx ];
      });
      solve_table.push( row_map );
    });
    return solve_table;
  }
  // . END utility /makeCommandTable/

  // BEGIN utility /filterByAlias/
  function filterByAlias ( map ) {
    return ( map.alias_list.indexOf( this ) > -1 );
  }
  // . END utility /filterByAlias/

  // BEGIN utility /getCommandMap/
  function getCommandMap ( row_id ) {
    var
      idx = parseInt( row_id, 10 ),
      filter_list
      ;

    if ( isNaN( idx ) ) {
      filter_list = commandTable.filter( filterByAlias, row_id );
    }
    else {
      filter_list = [ commandTable[ idx ] ];
    }
    return filter_list[ 0 ];
  }
  // . END utility /getCommandMap/


  // BEGIN utility /makePrefixStr/
  function makePrefixStr ( command_map ) {
    return appName + ' Stage ' + command_map.id + ' '
      + makeRightPadStr( command_map.alias_list[ 0 ], 14 ) + ': '
      ;
  }
  // . END utility /makePrefixStr/

  // BEGIN utility /makeParamMap/
  // Purpose   : Process command line arguments
  // Example   : makeParamMap( [ 'help', '1', '-v' ] )
  //   returns : { do_verbose: true, range_str : '1',
  //               stage_list : [ <commandRowHelp> ] }
  // Example   : makeParamMap( [ '1', '-v' ] )
  //   returns : { do_verbose: true, range_str : '1'
  //               stage_list : [ <commandRow1> ] }
  // Arguments : (positional)
  //   0) stage_list - list of command line arguments and switches
  //   1) skip_idx   - skip this number of arguments (not switches)
  // Returns   :  An object as follows:
  //   { do_verbose : <true|false>,
  //     range_str  : <cli_range_provided>,
  //     stage_list : [  <commandRow0>, <commandTableRow1, ...  ]
  //   }
  function makeParamMap ( param_list, arg_skip_idx ) {
    var
      arg_count  = 0,
      skip_idx   = arg_skip_idx || 0,

      do_verbose = false,
      range_str  = '',
      stage_list = null,

      edge_list, temp_list
      ;

    param_list.forEach( function ( str, ignore_idx ) {
      var i, first_map, middle_map, last_map, first_idx, last_idx;
      if ( str === '-v' ) {
        do_verbose = true;
        return;
      }

      // skip range list if already defined
      if ( stage_list ) { return true; }

      if ( str.match(/-/) || str === 'all' ) {
        if ( arg_count < skip_idx ) {
          arg_count++;
          return;
        }

        edge_list = str === 'all'
          ? [ 0, commandTable.length - __1 ]
          : str.split( '-', 2 );

        first_map = getCommandMap( edge_list[ __0 ] );
        last_map  = getCommandMap( edge_list[ __1 ] );
        if ( ! first_map ) {
          return warnFn( 'Range stage ' + edge_list[ __0 ] + ' is invalid' );
        }
        if ( ! last_map ) {
          return warnFn( 'Range stage ' + edge_list[ __1 ] + ' is invalid' );
        }
        if ( first_map.idx > last_map.idx ) {
          return warnFn(
            'Range start start ' + edge_list[ __0 ]
            + ' exceeds stage end ' + edge_list[ __1 ]
          );
        }

        temp_list = [ first_map ];

        first_idx = first_map.idx + __1;
        last_idx  = last_map.idx  - __1;

        for ( i = first_idx; i <= last_idx; i++ ) {
          middle_map = getCommandMap( i );
          if ( ! middle_map ) { return; }
          temp_list.push( middle_map );
        }
        if ( last_map !== first_map ) {
          temp_list.push( last_map );
        }

        range_str  = str;
        stage_list = temp_list;
        return;
      }

      if ( str.match(/,/) ) {
        if ( arg_count < skip_idx ) {
          arg_count++;
          return;
        }
        edge_list = str.split(',');
        temp_list = [];
        edge_list.forEach( function ( data, ignore_idx ) {
          middle_map = getCommandMap( data );
          if ( ! middle_map ) { return; }
          temp_list.push( middle_map );
        });

        range_str  = str;
        stage_list = temp_list;
        return;
      }

      if ( arg_count < skip_idx ) {
        arg_count++;
        return;
      }
      middle_map = getCommandMap( str );
      if ( ! middle_map ) { return; }

      range_str  = str;
      stage_list = [ middle_map ];
    });

    return {
      do_verbose : do_verbose,
      range_str  : range_str,
      stage_list : stage_list || []
    };
  }
  // . END utility /makeParamMap/

  // BEGIN utility /makeChangedJSList/
  function makeChangedJSList () { }
  // . END utility /makeChangedJSList/

  // BEGIN utlity /grepFileFn/
  function grepFileFn ( filename, pattern_str ) {
    return new Promise( function ( resolve_fn ) {
      var
        is_matched    = false,
        line_read_obj = new LineReader( filename, {skipEmptyLines:true })
        ;

      line_read_obj.on( 'error', abortFn );
      line_read_obj.on( 'line',  function ( line_str ) {
        if ( line_str.indexOf( pattern_str ) > -1 ) {
          is_matched = true;
          line_read_obj.close();
        }
      });
      line_read_obj.on( 'end', function () {
        resolve_fn( is_matched );
      });
    });
  }
  // . END utility /grepFileFn/

  // BEGIN utilities to return resolve and reject functions
  function makeRejectFuncFn ( reject_fn ) {
    return function ( error_data ) { reject_fn( error_data ); };
  }

  function makeResolveFuncFn ( resolve_fn ) {
    return function () { resolve_fn(); };
  }
  // . END utilities to return resolve and reject functions

  // BEGIN utility /copyPathFn/
  function copyPathFn( fq_src_path_str, fq_dest_path_str, do_dir_copy ) {
    if ( do_dir_copy ) {
      return new Promise( function ( resolve_fn, reject_fn ) {
        ncpFn( fq_src_path_str, fq_dest_path_str,
          function ( error_data ) {
            if ( error_data ) { return reject_fn(); }
            resolve_fn();
          }
        );
      });
    }

    return new Promise( function ( resolve_fn, reject_fn ) {
      var
        read_obj        = fsObj.createReadStream(  fq_src_path_str  ),
        write_obj       = fsObj.createWriteStream( fq_dest_path_str ),
        full_reject_fn  = makeRejectFuncFn(  reject_fn  ),
        full_resolve_fn = makeResolveFuncFn( resolve_fn )
        ;

      read_obj.on(  'error', full_reject_fn  );
      write_obj.on( 'error', full_reject_fn  );
      write_obj.on( 'close', full_resolve_fn );
      read_obj.pipe( write_obj );
    });
  }
  // . END utility /copyPathFn/

  // BEGIN utility /storePathFn/
  function storePathFn ( path_str ) {
    var
      ctx_obj = this,
      bin_key = ctx_obj.bin_key;

    if ( ! bin_key ) {
      abortFn( 'No key provided for ' + path_str );
    }
    binPathMap[ bin_key ]  = path_str;
  }
  // . END utility /storePathFn/

  // BEGIN utility /patchIfNeededFn/
  function patchIfNeededFn ( is_check_found ) {
    var ctx_obj = this;
    if ( is_check_found ) {
      logFn( '    Patch ' + ctx_obj.relative_name + ' already applied.' );
    }
    else {
      applyPatchFn( ctx_obj.relative_name );
      logFn( '    Applied patch ' + ctx_obj.relative_name );
    }
  }
  // . END utility /patchIfNeededFn/

  // BEGIN utility /loadPostInstallfn/
  // Loads libraries after stage 01 (install) is complete
  function loadLibsFn () {
    LineReader   = require( 'line-by-line' );
    applyPatchFn = require( 'apply-patch'  ).applyPatch;
    exeCpeFn     = require( 'execpe'       );
    flowObj      = require( 'flow'         );
    mkdirpFn     = require( 'mkdirp'       );
    ncpFn        = require( 'ncp'          ).ncp;
    rmDirFn      = require( 'rmdir'        );
    whichFn      = require( 'which'        );

    makeRmDirProm = promisifyFn( rmDirFn   );
    makeWhichProm = promisifyFn( whichFn   );
  }
  // . END utility /loadLibsFn/

  // BEGIN utility /checkBinListFn/
  function checkBinListFn () {
    var
      ctx_obj      = this,
      exe_list     = [ 'git', 'patch' ],
      exe_count    = exe_list.length,
      promise_list = [],

      idx, bin_key, bound_fn, promise_obj;

    // Assign executable path vars
    for ( idx = 0; idx < exe_count; idx++ ) {
      bin_key     = exe_list[ idx ];
      bound_fn    = storePathFn.bind( { bin_key : bin_key });
      promise_obj = makeWhichProm( bin_key );
      promise_obj.then( bound_fn ).catch( abortFn );
      promise_list.push( promise_obj );
    }

    promiseObj.all( promise_list )
      .then(   ctx_obj.then_fn )
      .catch( ctx_obj.catch_fn )
      ;
  }
  // . END utility /checkBinListFn/

  // BEGIN utility /checkNodeVersionFn/
  function checkNodeVersionFn () {
    var abort_str;
    if ( Number( versList[0] ) < minVersionInt ) {
      abort_str
        = 'NodeJS Version ' + versList.join('.') + ' is installed.\n'
        + 'As of ' + appName + '1.2 NodeJS v'
        + minVersionInt + ' is required.\n'
        + 'Please upgrade NodeJS and try again.'
        ;
      abortFn( abort_str );
    }
  }
  // . END utility /checkNodeVersionFn/

  // BEGIN utility /storePkgMapFn/
  function storePkgMapFn ( error_obj, json_str ) {
    var ctx_obj = this;
    if ( error_obj ) { return abortFn( error_obj ); }
    pkgMatrix   = JSON.parse( json_str ) || [];
    setupMatrix = pkgMatrix.xhi_02_SetupMatrix;
    if ( ! setupMatrix ) {
      abortFn( 'xhi_02_SetupMatrix not set in package.json' );
    }
    ctx_obj.then_fn();
  }
  // . END utility /storePkgMapFn/

  // BEGIN utility /readPkgFileFn/
  function readPkgFileFn () {
    var ctx_obj = this;
    fsObj.readFile( fqPkgFilename, 'utf8',
    storePkgMapFn.bind( ctx_obj ), abortFn );
  }
  // END utility /readPkgFileFn/

  // BEGIN utility /rmVendorDirsFn/
  function rmVendorDirsFn () {
    var
      ctx_obj            = this,
      asset_group_table  = setupMatrix.asset_group_table,
      asset_group_count  = asset_group_table.length,
      promise_list       = [],

      idx, asset_group_map, fq_dest_dir_str, promise_obj
      ;

    for ( idx = 0; idx < asset_group_count; idx++ ) {
      asset_group_map = asset_group_table[ idx ] || {};
      fq_dest_dir_str = fqProjDirname + '/' + asset_group_map.dest_dir_str;
      mkdirpFn.sync( fq_dest_dir_str );

      promise_obj = makeRmDirProm( fq_dest_dir_str );
      promise_list.push( promise_obj );
    }

    promiseObj.all( promise_list )
      .then(  ctx_obj.then_fn  )
      .catch( ctx_obj.catch_fn )
      ;
  }
  // . END utility /rmVendorDirsFn/

  // BEGIN utility /copyVendorFilesFn/
  function copyVendorFilesFn () {
    var
      ctx_obj            = this,
      asset_group_table  = setupMatrix.asset_group_table || [],
      dev_dependency_map = pkgMatrix.devDependencies     || {},
      asset_group_count  = asset_group_table.length,
      promise_list       = [],

      idx, asset_group_map, asset_list, asset_count,
      fq_dest_dir_str, dest_ext_str, do_dir_copy,

      idj, asset_map, src_asset_name, src_dir_str,
      src_pkg_name, dest_vers_str, dest_name,
      fq_src_path_list, fq_src_path_str,
      fq_dest_path_str, promise_obj
      ;

    for ( idx = 0; idx < asset_group_count; idx++ ) {
      asset_group_map = asset_group_table[ idx ] || {};

      asset_list  = asset_group_map.asset_list   || [];
      asset_count = asset_list.length;

      dest_ext_str     = asset_group_map.dest_ext_str;
      do_dir_copy      = asset_group_map.do_dir_copy;
      fq_dest_dir_str  = fqProjDirname + '/'
        + asset_group_map.dest_dir_str;

      mkdirpFn.sync( fq_dest_dir_str );
      ASSET_MAP: for ( idj = 0; idj < asset_count; idj++ ) {
        asset_map      = asset_list[ idj ];
        src_asset_name = asset_map.src_asset_name;
        src_dir_str    = asset_map.src_dir_str || '';
        src_pkg_name   = asset_map.src_pkg_name;

        dest_vers_str  = dev_dependency_map[ src_pkg_name ];

        if ( ! dest_vers_str ) {
          logFn( 'WARN: package ' + src_pkg_name + ' not found.');
          continue ASSET_MAP;
        }
        dest_name = asset_map.dest_name || src_pkg_name;

        fq_dest_path_str = fq_dest_dir_str
          + '/' + dest_name + '-' + dest_vers_str;
        fq_src_path_list = [ fqModuleDirname, src_pkg_name, src_asset_name ];
        if ( src_dir_str ) { fq_src_path_list.splice( 2, 0, src_dir_str ); }

        fq_src_path_str = fq_src_path_list.join( '/' );

        if ( ! do_dir_copy ) {
          fq_dest_path_str += '.' + dest_ext_str;
        }
        promise_obj = copyPathFn(
          fq_src_path_str, fq_dest_path_str, do_dir_copy
        );
        promise_list.push( promise_obj );
      }
    }

    promiseObj.all( promise_list )
      .then(  ctx_obj.then_fn  )
      .catch( ctx_obj.catch_fn );
  }
  // . END utility /copyVendorFilesFn/

  // BEGIN utility /patchFilesFn/
  // This function requires CWD to be fqProjDirname
  function patchFilesFn () {
    var
      ctx_obj          = this,
      patch_matrix     = setupMatrix.patch_matrix   || {},
      patch_dir_str    = patch_matrix.patch_dir_str || '',
      patch_map_list   = patch_matrix.patch_map_list|| [],
      patch_map_count  = patch_map_list.length,
      promise_list     = [],
      idx, patch_map, promise_obj,
      check_filename, patch_filename,
      bound_fn
      ;

    for ( idx = 0; idx < patch_map_count; idx++ ) {
      patch_map      = patch_map_list[ idx ];
      check_filename = patch_map.check_filename;
      patch_filename = patch_map.patch_filename;
      patch_map.relative_name = patch_dir_str + '/' + patch_filename;

      promise_obj    = grepFileFn( check_filename, patch_map.pattern_str );
      bound_fn       = patchIfNeededFn.bind( patch_map );
      promise_obj.then( bound_fn ).catch( abortFn );
      promise_list.push( promise_obj );
    }

    Promise.all( promise_list )
      .then(  ctx_obj.then_fn  )
      .catch( ctx_obj.catch_fn )
      ;
  }
  // . END utility /patchFilesFn/

  // BEGIN utility /checkGitInstallFn/
  function checkGitInstallFn () {
    var
      ctx_obj = this,
      promise_obj = makeStatProm( fqGitDirname )
      ;

    promise_obj
      .then( function () {
        logFn( '    Git directory ' + fqGitDirname + ' found.');
        ctx_obj.then_fn();
      })
      .catch( function () {
        logFn( '    Git directory ' + fqGitDirname + ' NOT found.');
        ctx_obj.catch_fn();
      });
  }
  // . END utility /checkGitInstallFn/

  // BEGIN utility /unlinkHookFn/
  // This ignores any error
  function unlinkHookFn () {
    var ctx_obj = this;
    fqHookFilename = fqProjDirname + '/.git/hooks/pre-commit';
    fsObj.unlink( fqHookFilename, ctx_obj.then_fn );
  }
  // . END utility /unlinkHookFn/

  // BEGIN utility /linkHookFn/
  // This function requires CWD to be fqProjDirname
  function linkHookFn () {
    var ctx_obj = this;
    fsObj.symlink(
      '../../bin/git-hook_pre-commit',
      fqHookFilename,
      function ( error_data ) {
        if ( error_data ) { abortFn( error_data ); }
        ctx_obj.then_fn();
      }
    );
  }
  // . END utility /linkHookFn/
  // == END UTILITY METHODS ============================================

  // == BEGIN EVENT HANDLERS ===========================================
  // function makeBoundEmitFn ( signal_str ) {
  //   return function () { eventObj.emit( signal_str ); };
  // }
  // == . END EVENT HANDLERS ==========================================

  // BEGIN utility /makeXhiObj/
  // Purpose: Creates resource map for modules available
  //   only after npm install.
  //
  function makeXhiObj () {
    return {
      checkBinListFn    : checkBinListFn,    // .  .  02
      checkGitInstallFn : checkGitInstallFn, // .  .  02
      copyVendorFilesFn : copyVendorFilesFn, // .  .  02
      exeCpeFn          : exeCpeFn,          // .  .  .
      binPathMap        : binPathMap,        // .  .  .  03
      flowObj           : flowObj,           // .  .  02
      fqModuleDirname   : fqModuleDirname,   // .  .  .
      linkHookFn        : linkHookFn,        // .  .  02
      patchFilesFn      : patchFilesFn,      // .  .  02
      readPkgFileFn     : readPkgFileFn,     // .  .  02
      rmVendorDirsFn    : rmVendorDirsFn,    // .  .  02
      unlinkHookFn      : unlinkHookFn       // .  .  02
    };
  }
  // . END utility /makeXhiObj/

  // BEGIN utility /makeSetObj/
  // Purpose: Create object to provide as context to lib functions
  //  nextFn and catchFn are defaults.
  //
  function makeSetObj () {
    return {
      appName         : appName,        // Applicaiton name
      catchFn         : abortFn,        // Fn for error
      commandMap      : null,           // Command map of lib to exec
      fqOrigDirname   : fqOrigDirname,  // Full path of PWD
      fqProjDirname   : fqProjDirname,  // Full path of root project dir
      getCommandMap   : getCommandMap,  // Get command map by id or index
      loadLibsFn      : loadLibsFn,     // Load libs after stage 1
      logFn           : logFn,          // Log to console
      makePrefixStr   : makePrefixStr,  // Fn for stage prefix
      makeRightPadStr : makeRightPadStr,// Pad string right
      makeSpawnObj    : makeSpawnObj,   // Object create spawned proc
      makeXhiObj      : makeXhiObj,     // Get utils after stage 1
      nextFn          : exitFn,         // Fn for success
      paramMap        : null,           // Parameters per CLI input
      warnFn          : warnFn          // Warn to console
    };
  }
  // . END utility /makeSetObj/

// TODO Add to command table info
//
// Stages correlated wth npm
// "00": "bin/xhi 00",
// "00_.": "=== HELP",
// "01": "bin/xhi 01",
// "01_.": "=== INSTALL",
// "01_a": "...node preinstall: Run BEFORE the pkg is installed",
// "02": "bin/xhi 02",
// "02_.": "=== SETUP",
// "02_a": "...node install, postinstall: Run AFTER the pkg is installed.",
// "03": "bin/xhi 03",
// "03_.": "=== DESIGN",
// "03__": "...synonym cat /doc/spa-arch.md",
// "04": "bin/xhi 04",
// "04_.": "=== DEVSERVER-START",
// "04_1": "...node start",
// "04_2": "...node poststart",
// "04_a": "...node prestart",
// "05": "bin/xhi 05",
// "05_.": "=== GIT PULL",
// "06": "bin/xhi 06",
// "06_.": "=== DEVELOP-LINT",
// "07": "bin/xhi 07",
// "07_.": "=== DEVELOP-TEST",
// "07_a": "...node pretest, test, posttest: Run by the npm test command.",
// "08": "bin/xhi 08",
// "08_.": "=== DEVELOP-COVERAGE",
// "09": "bin/xhi 09",
// "09_.": "=== DEVELOP-COMMIT",
// "09_1": "...node postversion: Run AFTER bumping the pkg version, and AFTER commit.",
// "09_a": "...node preversion: Run BEFORE bumping the pkg version.",
// "09_b": "...node version: Run AFTER bumping the pkg version, but BEFORE commit.",
// "10": "bin/xhi 10",
// "10_.": "=== BUILD",
// "10_a": "...node prepare: Run both BEFORE the pkg is packed and published, and on local npm install without any arguments (See below). This is run AFTER prepublish, but BEFORE prepublishOnly.",
// "11": "bin/xhi 11",
// "11_.": "=== PUBLISH",
// "11_1": "...node publish",
// "11_2": "...node postpublish: Run AFTER the pkg is published.",
// "11_a": "...node prepublish: Run BEFORE the pkg is packed and published, as well as on local npm install without any arguments. (See below)",
// "11_b": "...node prepublishOnly: Run BEFORE the pkg is prepared and packed, ONLY on npm publish. (See below.)",
// "12": "bin/xhi 12",
// "12_.": "=== DEVSERVER-RESTART",
// "12_1": "...node restart",
// "12_2": "...node postrestart",
// "12_3": "...node WARN: npm restart will run the stop and start scripts if no restart script is provided.",
// "12_a": "...node prerestart",
// "13": "bin/xhi 13",
// "13_.": "=== DEVSERVER-STOP",
// "13_1": "...node stop",
// "13_2": "...node poststop",
// "13_a": "...node prestop",
// "14": "bin/xhi 14",
// "14_.": "=== DEPLOY",
// "14_1": "...node postpack: Run AFTER the tarball has been generated and moved to its final destination.",
// "14_a": "...node preshrinkwrap, shrinkwrap, postshrinkwrap: Run by the npm shrinkwrap command.",
// "14_b": "...node prepack: run BEFORE a tarball is packed (on npm pack, npm publish, and when installing git dependencies)",
// "15": "bin/xhi 15",
// "15_.": "=== PRODSERVER-START",
// "16": "bin/xhi 16",
// "16_.": "=== PRODSERVER-RESTART",
// "17": "bin/xhi 17",
// "17_.": "=== PRODSERVER-STOP",
// "18": "bin/xhi 18",
// "18_.": "=== FEEDBACK",
// "19": "bin/xhi 19",
// "19_.": "=== UNINSTALL",
// "19_1": "...node preuninstall, uninstall: Run BEFORE the pkg is uninstalled.",
// "19_2": "...node postuninstall: Run AFTER the pkg is uninstalled.",
  commandTable = makeCommandTable([
    [ 'alias_list', 'short_str',  'long_str' ],
    [ [ 'help' ],
      'Hi_score admin tool. Use -v for verbose.',
      '\n  Name      : ' + appName + '\n'
      + '  Purpose   : Run hi_score lifecycle tools\n'
      + '  Example   : xhi help\n'
      + '  Arguments : [ help || 0 ] /range/ [ -v ]\n'
      + '    /range/ may be:\n'
      + '    1. A single stage number or name.    Ex: 01.\n'
      + '    2. A list of stage numbers or names. Ex: 1,2,3,6.\n'
      + '    3. A range of stages                 Ex: 1-5 or all\n'
      + '    See ' + appName + ' help all to list stages.\n'
      + '  More examples:\n'
      + '    Run stage range\n'
      + padName + ' dev_pull        // run stage 04\n'
      + padName + ' 1,2,6           // run three stages\n'
      + padName + ' 1-9             // run nine stages in range\n'
      + '    Generic help\n'
      + padName + ' help            // Short help \n'
      + '    Help stage range\n'
      + padName + ' help 01         // Short help on install stage\n'
      + padName + ' help all -v     // Long help on all stages\n'
      + padName + ' help 1,4        // Short help on stages 1,4\n'
      + padName + ' help help,dev_pull -v // Long help on stages 1,4'
    ],
    [ [ 'install' ],
      'Download & install npm modules.',
      'Download & install npm modules.'
    ],
    [ [ 'setup'         ], 'Patch+copy dev assets'     ],
    [ [ 'design'        ], 'Show architecture docs'    ],
    [ [ 'dev_pull'      ], 'Download assets (git pull)'],
    [ [ 'dev_start'     ], 'Start local web services'  ],
    [ [ 'dev_lint'      ], 'Lint changed code'         ],
    [ [ 'dev_test'      ], 'Run regression tests'      ],
    [ [ 'dev_cover'     ], 'Create coverage report'    ],
    [ [ 'dev_commit'    ], 'Save code (git commit)'    ],
    [ [ 'build', 'make' ], 'Create app distribution'   ],
    [ [ 'publish'       ], 'Upload to NPM, Coveralls'  ],
    [ [ 'dev_restart'   ], 'Cycle local web server'    ],
    [ [ 'dev_stop'      ], 'Stop development server'   ],
    [ [ 'upgrade'       ], 'Upgrade packages (ncu -u)' ],
    [ [ 'deploy'        ], 'Upload distro to servers'  ],
    [ [ 'prod_start'    ], 'Start prod web services'   ],
    [ [ 'prod_restart'  ], 'Cycle production process'  ],
    [ [ 'prod_stop'     ], 'Stop production process'   ],
    [ [ 'fetch_info'    ], 'Fetch prod info'           ],
    [ [ 'uninstall'     ], 'Remove ' + appName         ]
  ]);
  // == BEGIN PUBLIC METHOD /mainFn/ ==================================
  // Purpose   : Parse command line and dispatch to requested command(s)
  function mainFn( arg_param_list ) {
    var
      param_list = arg_param_list.slice( 2 ),
      param_map  = makeParamMap( param_list ),
      stage_list = param_map.stage_list,
      exec_list  = [],

      command_map, set_obj,  stage_idx,
      stage_fn,    bound_fn
      ;

    // Abort if node version < minVersionInt
    checkNodeVersionFn();
    command_map = stage_list[ __0 ];

    // Make new set_obj as context for lib function
    set_obj = makeSetObj();

    // Special case: help
    if ( ! command_map
      || param_map.range_str === ''
      || param_map.range_str.match(/^0+$/)
      || param_map.range_str === 'help'
    ) {
      command_map = getCommandMap( __0 );
      set_obj.commandMap = command_map;
      set_obj.paramMap   = makeParamMap( param_list, __1 );
      set_obj.doListShow = true;
      stage_fn = require( fqLibDirname + '/xhi_00.js' );
      return stage_fn.call( set_obj );
    }

    // Begin exec standard stage list
    // Walk backward through list and bind functions.
    // The last function should have nextFn set to exit function.
    // The second-to-last function should have nextFn set to
    //   the last function.
    // The third-to-last function should have nextFn set to
    //   the second-to-last function, etc.
    //
    set_obj.nextFn = function _nextFn () {
      exitFn( 'Process range ' + param_map.range_str + ': Success');
    };

    stage_idx = stage_list.length - __1;
    while ( stage_idx > -1 ) {

      // Set commandMap, paramMap in context object
      command_map = stage_list[ stage_idx ];
      set_obj.commandMap = command_map;
      set_obj.paramMap   = param_map;

      // Load library ( TODO load preq_list? )
      stage_fn = require( fqLibDirname + '/xhi_' + command_map.id + '.js' );

      // Build exec chain
      bound_fn = stage_fn.bind( set_obj );
      exec_list.push( bound_fn );

      // Make new context object and set catchFn, nextFn
      if ( stage_idx > __0 ) {
        set_obj = makeSetObj();
        set_obj.nextFn  = bound_fn;
      }
      stage_idx--;
    }
    logFn( 'Process range ' + param_map.range_str + ': Start');
    if ( bound_fn ) { return bound_fn(); }
    // End exec standard stage list
  }
  // == . END PUBLIC METHOD /mainFn/ ==================================

  mainFn( argList );
// == . END SCRIPT xhi - the hi_score cli life-stage tool =============

