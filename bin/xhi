#!/usr/bin/node
/* vim: set ft=javascript: */
/*
 * Purpose   : Run hi_score lifecycle tools
 * Example   : See xhi help (_00HelpFn)
 * Author    : Michael S. Mikowski - mike.mikowski@gmail.com
 *
*/
/*jslint node : true */
/*global Promise */

// TODO move all npm script to xhi helper
//
// Stages correlated wth npm
// "00": "bin/xhi 00",
// "00_.": "=== HELP",
// "01": "bin/xhi 01",
// "01_.": "=== INSTALL",
// "01_a": "...node preinstall: Run BEFORE the pkg is installed",
// "02": "bin/xhi 02",
// "02_.": "=== SETUP",
// "02_a": "...node install, postinstall: Run AFTER the pkg is installed.",
// "03": "bin/xhi 03",
// "03_.": "=== DESIGN",
// "03__": "...synonym cat /doc/spa-arch.md",
// "04": "bin/xhi 04",
// "04_.": "=== DEVSERVER-START",
// "04_1": "...node start",
// "04_2": "...node poststart",
// "04_a": "...node prestart",
// "05": "bin/xhi 05",
// "05_.": "=== GIT PULL",
// "06": "bin/xhi 06",
// "06_.": "=== DEVELOP-LINT",
// "07": "bin/xhi 07",
// "07_.": "=== DEVELOP-TEST",
// "07_a": "...node pretest, test, posttest: Run by the npm test command.",
// "08": "bin/xhi 08",
// "08_.": "=== DEVELOP-COVERAGE",
// "09": "bin/xhi 09",
// "09_.": "=== DEVELOP-COMMIT",
// "09_1": "...node postversion: Run AFTER bumping the pkg version, and AFTER commit.",
// "09_a": "...node preversion: Run BEFORE bumping the pkg version.",
// "09_b": "...node version: Run AFTER bumping the pkg version, but BEFORE commit.",
// "10": "bin/xhi 10",
// "10_.": "=== BUILD",
// "10_a": "...node prepare: Run both BEFORE the pkg is packed and published, and on local npm install without any arguments (See below). This is run AFTER prepublish, but BEFORE prepublishOnly.",
// "11": "bin/xhi 11",
// "11_.": "=== PUBLISH",
// "11_1": "...node publish",
// "11_2": "...node postpublish: Run AFTER the pkg is published.",
// "11_a": "...node prepublish: Run BEFORE the pkg is packed and published, as well as on local npm install without any arguments. (See below)",
// "11_b": "...node prepublishOnly: Run BEFORE the pkg is prepared and packed, ONLY on npm publish. (See below.)",
// "12": "bin/xhi 12",
// "12_.": "=== DEVSERVER-RESTART",
// "12_1": "...node restart",
// "12_2": "...node postrestart",
// "12_3": "...node WARN: npm restart will run the stop and start scripts if no restart script is provided.",
// "12_a": "...node prerestart",
// "13": "bin/xhi 13",
// "13_.": "=== DEVSERVER-STOP",
// "13_1": "...node stop",
// "13_2": "...node poststop",
// "13_a": "...node prestop",
// "14": "bin/xhi 14",
// "14_.": "=== DEPLOY",
// "14_1": "...node postpack: Run AFTER the tarball has been generated and moved to its final destination.",
// "14_a": "...node preshrinkwrap, shrinkwrap, postshrinkwrap: Run by the npm shrinkwrap command.",
// "14_b": "...node prepack: run BEFORE a tarball is packed (on npm pack, npm publish, and when installing git dependencies)",
// "15": "bin/xhi 15",
// "15_.": "=== PRODSERVER-START",
// "16": "bin/xhi 16",
// "16_.": "=== PRODSERVER-RESTART",
// "17": "bin/xhi 17",
// "17_.": "=== PRODSERVER-STOP",
// "18": "bin/xhi 18",
// "18_.": "=== FEEDBACK",
// "19": "bin/xhi 19",
// "19_.": "=== UNINSTALL",
// "19_1": "...node preuninstall, uninstall: Run BEFORE the pkg is uninstalled.",
// "19_2": "...node postuninstall: Run AFTER the pkg is uninstalled.",
// == BEGIN SCRIPT xhi - the hi_score cli tool ========================
  // == BEGIN MODULE SCOPE VARIABLES ==================================
  'use strict';
  var
    // Import capabilities
    EventEmitter = require( 'events' ).EventEmitter,
    childProcObj = require( 'child_process' ),
    fsObj        = require( 'fs'            ),
    npmObj       = require( 'npm'           ),
    pathObj      = require( 'path'          ),
    utilObj      = require( 'util'          ),
    promiseObj   = Promise,

    // execFn       = childProcObj.exec,
    makeSpawnObj = childProcObj.spawn,

    // Convert to promises using promisfy
    promisifyFn   = utilObj.promisify,
    makeStatProm  = promisifyFn( fsObj.stat ),

    // Assign nodejs builtins
    eventObj      = new EventEmitter(),
    fqAppFilename = __filename,
    fqBinDirname  = __dirname,

    // Get environment values
    appName       = pathObj.basename( fqAppFilename, '.js' ),
    argList       = process.argv,
    fqOrigDirname = process.cwd(), // or pathObj.resolve()
    versList      = process.versions.node.split('.'),

    // Set paths
    fqProjDirname   = pathObj.dirname( fqBinDirname ),
    fqGitDirname    = fqProjDirname   + '/.git',
    fqModuleDirname = fqProjDirname   + '/node_modules',
    fqPkgFilename   = fqProjDirname   + '/package.json',
    fqPatchFilename = fqProjDirname   + '/patch/uglify-js-3.0.21.patch',

    fqUglyDirname   = fqModuleDirname + '/uglifyjs',
    fqScopeFileStr  = fqUglyDirname   + '/lib/scope.js',

    // Set minimum Node verion number and init empty map
    minVersionInt  = 8,
    exePathMap     = {},

    // Set convenience vars
    __0 = 0,
    __1 = 1,

    // Declare curried functions
    abortFn, exitFn, logFn, warnFn,

    // Declare config data
    fqHookFilename,  pkgMatrix,    setupMatrix,
    rawCommandTable, commandTable,

    // Declare after-install-variables
    LineReader,    applyPatchFn,  exeCpeFn,
    flowObj,       mkdirpFn,      ncpFn,
    rmDirFn,       whichFn,       makeWhichProm,
    makeRmDirProm  
    ;
  // == . END MODULE SCOPE VARIABLES ==================================

  // == BEGIN UTILITY METHODS =========================================
  // BEGIN utility /_outFn/
  // Purpose: provides abortFn, exitFn, logFn, and warnFn
  function _outFn() {
    var
      context_obj = this || {},
      method_str = context_obj._method_str_ || 'log',
      prompt_str = context_obj._prompt_str_ || appName + '-info> ',
      arg_list   = Array.from( arguments )
      ;

    if ( arg_list.length > 0 ) {
      arg_list.unshift( prompt_str );
      console[ method_str ].apply( null, arg_list );
    }
    if ( context_obj._cwd_name_ ) {
      process.chdir( context_obj._cwd_name_ );
    }
    if ( context_obj._do_abort ) { process.exit( 1 ); }
    if ( context_obj._do_exit  ) { process.exit( 0 ); }
  }
  abortFn = _outFn.bind({
    _cwd_name_   : fqOrigDirname,
    _do_abort_   : true,
    _method_str_ : 'warn',
    _prompt_str_ : appName + '-abort> ',
  });
  exitFn = _outFn.bind({
    _cwd_name_   : fqOrigDirname,
    _do_exit_    : true,
    _prompt_str_ : appName + '-exit> ',
  });
  logFn   = _outFn.bind();
  warnFn  = _outFn.bind({
    _method_str_ : 'warn',
    _prompt_str_ : appName + '-warn> '
  });
  // . END utility /_outFn/

  // BEGIN utility /makeParamMap/
  // Purpose: return a map like
  //   { range_list : [ 0,1,2,3,4 ], do_verbose : true }
  function makeParamMap ( param_list ) {
    var 
      do_verbose = false,
      i, edge_list, range_list
      ;

    param_list.forEach( function ( str, idx ) {
      if ( str === '-v' ) {
        do_verbose = true;
        return;
      }

      // skip range list if already defined
      if ( range_list ) { return true; } 

      if ( str.match(/-/) ) {
        edge_list  = str.split( '-', 2 );
        range_list = [];

        for ( i = Number( edge_list[ 0 ] ); i <= Number( edge_list[ 1 ] ); i++ ) {
          range_list.push( i );
        }
        return;
      }

      if ( str.match(/,/) ) {
        range_list = str.spit(',');
        range_list.forEach( function ( data, idx ) {
          range_list[ idx ] = Number( data );
        });
        return;
      }

      if ( ! isNaN( Number( str ) ) ) {
        range_list = [ Number( str ) ];
      }
    });

    return {
      do_verbose : do_verbose,
      range_list : range_list
    };
  }
  // . END utility /makeParamMap/

  // BEGIN utility /makeCommandTable/
  function makeCommandTable ( raw_table ) {
    var
      head_row    = raw_table.shift(),
      solve_table = []
      ;

    raw_table.forEach( function ( src_list, row_idx ) {
      var row_id = String( row_idx ), row_map;
      if ( row_id.length < 2 ) { row_id = '0' + row_id; }
      row_map = { id : row_id, idx : row_idx };
      head_row.forEach( function ( head_val, head_idx ) {
        row_map[ head_val ] = src_list[ head_idx ];
      });
      solve_table.push( row_map );
    });
    return solve_table;
  }
  // . END utility /makeCommandTable/

  // BEGIN utility /filterByAlias/
  function filterByAlias ( map ) {
    return ( map.alias_list.indexOf( this ) > -1 );
  }
  // . END utility /filterByAlias/

  // BEGIN utility /getTableRowMap/
  function getTableRowMap ( row_id ) {
    var
      idx = parseInt( row_id, 10 ),
      filter_list
      ;

    if ( isNaN( idx ) ) {
      filter_list = commandTable.filter( filterByAlias, row_id );
    }
    else {
      filter_list = [ commandTable[ idx ] ];
    }
    return filter_list[ 0 ];
  }
  // . END utility /getTableRowMap/

  // BEGIN utlity /grepFileFn/
  function grepFileFn ( filename, pattern_str ) {
    return new Promise( function ( resolve_fn ) {
      var
        is_matched    = false,
        line_read_obj = new LineReader( filename, {skipEmptyLines:true })
        ;

      line_read_obj.on( 'error', abortFn );
      line_read_obj.on( 'line',  function ( line_str ) {
        if ( line_str.indexOf( pattern_str ) > -1 ) {
          is_matched = true;
          line_read_obj.close();
        }
      });
      line_read_obj.on( 'end', function () {
        resolve_fn( is_matched );
      });
    });
  }
  // . END utility /grepFileFn/

  // BEGIN utilities to return resolve and reject functions
  function makeRejectFuncFn ( reject_fn ) {
    return function ( error_data ) { reject_fn( error_data ); };
  }

  function makeResolveFuncFn ( resolve_fn ) {
    return function () { resolve_fn(); };
  }
  // . END utilities to return resolve and reject functions

  // BEGIN utility /copyPathFn/
  function copyPathFn( fq_src_path_str, fq_dest_path_str, do_dir_copy ) {
    if ( do_dir_copy ) {
      return new Promise( function ( resolve_fn, reject_fn ) {
        ncpFn( fq_src_path_str, fq_dest_path_str,
          function ( error_data ) {
            if ( error_data ) { return reject_fn(); }
            resolve_fn();
          }
        );
      });
    }

    return new Promise( function ( resolve_fn, reject_fn ) {
      var
        read_obj        = fsObj.createReadStream(  fq_src_path_str  ),
        write_obj       = fsObj.createWriteStream( fq_dest_path_str ),
        full_reject_fn  = makeRejectFuncFn(  reject_fn  ),
        full_resolve_fn = makeResolveFuncFn( resolve_fn )
        ;

      read_obj.on(  'error', full_reject_fn  );
      write_obj.on( 'error', full_reject_fn  );
      write_obj.on( 'close', full_resolve_fn );
      read_obj.pipe( write_obj );
    });
  }
  // . END utility /copyPathFn/

  // BEGIN utility /storePathFn/
  function storePathFn ( path_str ) {
    var
      context_obj = this,
      exe_key = context_obj.exe_key;

    if ( ! exe_key ) {
      abortFn( 'No key provided for ' + path_str );
    }
    exePathMap[ exe_key ] = path_str;
  }
  // . END utility /storePathFn/

  // BEGIN utility /patchIfNeededFn/
  function patchIfNeededFn ( is_check_found ) {
    var context_obj = this;
    if ( is_check_found ) {
      logFn( 'Patch ' + context_obj.relative_name + ' already applied.' );
    }
    else {
      applyPatchFn( context_obj.relative_name );
      logFn( 'Applied patch ' + context_obj.relative_name );
    }
  }
  // . END utility /patchIfNeededFn/

  // BEGIN utility /loadPostInstallfn/
  // Loads libraries after stage 01 (install) is complete
  function loadPostInstallFn () {
    LineReader   = require( 'line-by-line' );
    applyPatchFn = require( 'apply-patch'  ).applyPatch;
    exeCpeFn     = require( 'execpe'       );
    flowObj      = require( 'flow'         );
    mkdirpFn     = require( 'mkdirp'       );
    ncpFn        = require( 'ncp'          ).ncp;
    rmDirFn      = require( 'rmdir'        );
    whichFn      = require( 'which'        );

    makeRmDirProm = promisifyFn( rmDirFn   );
    makeWhichProm = promisifyFn( whichFn   );
  }
  // . END utility /loadPostInstallFn/

  // BEGIN utility /checkExeList/
  function checkExeList () {
    var
      context_obj  = this,
      exe_list     = [ 'git', 'patch' ],
      exe_count    = exe_list.length,
      promise_list = [],

      idx, exe_key, bound_fn, promise_obj;

    // Assign executable path vars
    for ( idx = 0; idx < exe_count; idx++ ) {
      exe_key     = exe_list[ idx ];
      bound_fn    = storePathFn.bind( { exe_key : exe_key });
      promise_obj = makeWhichProm( exe_key );
      promise_obj.then( bound_fn ).catch( abortFn );
      promise_list.push( promise_obj );
    }

    promiseObj.all( promise_list )
      .then(   context_obj.then_fn )
      .catch( context_obj.catch_fn )
      ;
  }
  // . END utility /checkExeList/

  // BEGIN utility /checkNodeVersion/
  function checkNodeVersion () {
    var abort_str;
    if ( Number( versList[0] ) < minVersionInt ) {
      abort_str
        = 'NodeJS Version ' + versList.join('.') + ' is installed.\n'
        + 'As of ' + appName + '1.2 NodeJS v'
        + minVersionInt + ' is required.\n'
        + 'Please upgrade NodeJS and try again.'
        ;
      abortFn( abort_str );
    }
  }
  // . END utility /checkNodeVersion/

  // BEGIN utility /storePkgMapFn/
  function storePkgMapFn ( error_obj, json_str ) {
    var context_obj = this;
    if ( error_obj ) { return abortFn( error_obj ); }
    pkgMatrix   = JSON.parse( json_str ) || [];
    setupMatrix = pkgMatrix.xhi_02_SetupMatrix;
    if ( ! setupMatrix ) {
      abortFn( 'xhi_02_SetupMatrix not set in package.json' );
    }
    context_obj.then_fn();
  }
  // . END utility /storePkgMapFn/

  // BEGIN utility /readPkgFileFn/
  function readPkgFileFn () {
    var context_obj = this;
    fsObj.readFile( fqPkgFilename, 'utf8',
    storePkgMapFn.bind( context_obj ), abortFn );
  }
  // END utility /readPkgFileFn/

  // BEGIN utility /rmVendorDirsFn/
  function rmVendorDirsFn () {
    var
      context_obj        = this,
      asset_group_table  = setupMatrix.asset_group_table,
      asset_group_count  = asset_group_table.length,
      promise_list       = [],

      idx, asset_group_map, fq_dest_dir_str, promise_obj
      ;

    for ( idx = 0; idx < asset_group_count; idx++ ) {
      asset_group_map = asset_group_table[ idx ] || {};
      fq_dest_dir_str = fqProjDirname + '/' + asset_group_map.dest_dir_str;
      mkdirpFn.sync( fq_dest_dir_str );

      promise_obj = makeRmDirProm( fq_dest_dir_str );
      promise_list.push( promise_obj );
    }

    promiseObj.all( promise_list )
      .then(  context_obj.then_fn )
      .catch( context_obj.catch_fn )
      ;
  }
  // . END utility /rmVendorDirsFn/

  // BEGIN utility /copyVendorFilesFn/
  function copyVendorFilesFn () {
    var
      context_obj        = this,
      asset_group_table  = setupMatrix.asset_group_table || [],
      dev_dependency_map = pkgMatrix.devDependencies     || {},
      asset_group_count  = asset_group_table.length,
      promise_list       = [],

      idx, asset_group_map, asset_list, asset_count,
      fq_dest_dir_str, dest_ext_str, do_dir_copy,

      idj, asset_map, src_asset_name, src_dir_str,
      src_pkg_name, dest_vers_str, dest_name,
      fq_src_path_list, fq_src_path_str,
      fq_dest_path_str, promise_obj
      ;

    for ( idx = 0; idx < asset_group_count; idx++ ) {
      asset_group_map = asset_group_table[ idx ] || {};

      asset_list  = asset_group_map.asset_list   || [];
      asset_count = asset_list.length;

      dest_ext_str     = asset_group_map.dest_ext_str;
      do_dir_copy      = asset_group_map.do_dir_copy;
      fq_dest_dir_str  = fqProjDirname + '/'
        + asset_group_map.dest_dir_str;

      mkdirpFn.sync( fq_dest_dir_str );
      ASSET_MAP: for ( idj = 0; idj < asset_count; idj++ ) {
        asset_map      = asset_list[ idj ];
        src_asset_name = asset_map.src_asset_name;
        src_dir_str    = asset_map.src_dir_str || '';
        src_pkg_name   = asset_map.src_pkg_name;

        dest_vers_str  = dev_dependency_map[ src_pkg_name ];

        if ( ! dest_vers_str ) {
          logFn( 'WARN: package ' + src_pkg_name + ' not found.');
          continue ASSET_MAP;
        }
        dest_name = asset_map.dest_name || src_pkg_name;

        fq_dest_path_str = fq_dest_dir_str
          + '/' + dest_name + '-' + dest_vers_str;
        fq_src_path_list = [ fqModuleDirname, src_pkg_name, src_asset_name ];
        if ( src_dir_str ) { fq_src_path_list.splice( 2, 0, src_dir_str ); }

        fq_src_path_str = fq_src_path_list.join( '/' );

        if ( ! do_dir_copy ) {
          fq_dest_path_str += '.' + dest_ext_str;
        }
        promise_obj = copyPathFn(
          fq_src_path_str, fq_dest_path_str, do_dir_copy
        );
        promise_list.push( promise_obj );
      }
    }

    promiseObj.all( promise_list )
      .then(  context_obj.then_fn  )
      .catch( context_obj.catch_fn );
  }
  // . END utility /copyVendorFilesFn/

  // BEGIN utility /patchFilesFn/
  // This function requires CWD to be fqProjDirname
  function patchFilesFn () {
    var
      context_obj      = this,
      patch_matrix     = setupMatrix.patch_matrix   || {},
      patch_dir_str    = patch_matrix.patch_dir_str || '',
      patch_map_list   = patch_matrix.patch_map_list|| [],
      patch_map_count  = patch_map_list.length,
      promise_list     = [],
      idx, patch_map, promise_obj,
      check_filename, patch_filename,
      bound_fn
      ;

    for ( idx = 0; idx < patch_map_count; idx++ ) {
      patch_map      = patch_map_list[ idx ];
      check_filename = patch_map.check_filename;
      patch_filename = patch_map.patch_filename;
      patch_map.relative_name = patch_dir_str + '/' + patch_filename;

      promise_obj    = grepFileFn( check_filename, patch_map.pattern_str );
      bound_fn       = patchIfNeededFn.bind( patch_map );
      promise_obj.then( bound_fn ).catch( abortFn );
      promise_list.push( promise_obj );
    }

    Promise.all( promise_list )
      .then(  context_obj.then_fn  )
      .catch( context_obj.catch_fn )
      ;
  }
  // . END utility /patchFilesFn/

  // BEGIN utility /checkGitInstallFn/
  function checkGitInstallFn () {
    var
      context_obj = this,
      promise_obj = makeStatProm( fqGitDirname )
      ;

    promise_obj
      .then( function () {
        logFn( 'Git directory ' + fqGitDirname + ' found.');
        context_obj.then_fn();
      })
      .catch( function () {
        logFn( 'Git directory ' + fqGitDirname + ' NOT found.');
        context_obj.catch_fn();
      });
  }
  // . END utility /checkGitInstallFn/

  // BEGIN utility /unlinkHookFn/
  // This ignores any error
  function unlinkHookFn () {
    var context_obj = this;
    fqHookFilename = fqProjDirname + '/.git/hooks/pre-commit';
    fsObj.unlink( fqHookFilename, context_obj.then_fn );
  }
  // . END utility /unlinkHookFn/

  // BEGIN utility /linkHookFn/
  // This function requires CWD to be fqProjDirname
  function linkHookFn () {
    var context_obj = this;
    fsObj.symlink(
      '../../bin/git-hook_pre-commit',
      fqHookFilename,
      function ( error_data ) {
        if ( error_data ) { abortFn( error_data ); }
        context_obj.then_fn();
      }
    );
  }
  // . END utility /linkHookFn/
  // == END UTILITY METHODS ============================================

  // == BEGIN EVENT HANDLERS ===========================================
  // function makeBoundEmitFn ( signal_str ) {
  //   return function () { eventObj.emit( signal_str ); };
  // }
  // == . END EVENT HANDLERS ==========================================

  // BEGIN utility /makeXhiObj/
  // Purpose: Creates context_obj for module libraries
  //
  function makeXhiObj ( arg_map ) {
    return {
      catch_fn    : arg_map.catch_fn,
      command_map : arg_map.command_map,
      next_fn     : arg_map.next_fn,
      param_map   : arg_map.param_map,

      // TODO remove these in favor of catch_fn and next_fn
      abortFn           : abortFn,
      exitFn            : exitFn,

      appName           : appName,
      checkExeList      : checkExeList,
      checkGitInstallFn : checkGitInstallFn,
      commandTable      : commandTable,
      copyVendorFilesFn : copyVendorFilesFn,
      exeCpeFn          : exeCpeFn,
      flowObj           : flowObj,
      fqModuleDirname   : fqModuleDirname,
      fqOrigDirname     : fqOrigDirname,
      fqProjDirname     : fqProjDirname,
      linkHookFn        : linkHookFn,
      logFn             : logFn,
      makeSpawnObj      : makeSpawnObj,
      patchFilesFn      : patchFilesFn,
      readPkgFileFn     : readPkgFileFn,
      rmVendorDirsFn    : rmVendorDirsFn,
      unlinkHookFn      : unlinkHookFn,
      warnFn            : warnFn,
    };
  }
  // . END utility /makeXhiObj/

  // == BEGIN PUBLIC METHOD /_00HelpFn/ ===============================
  function _00HelpFn ( arg_list ) {
    var
      help_fn = require( fqBinDirname + '/xhi_00' ),
      xhi_obj = makeXhiObj( arg_list )
      ;

    help_fn.call( xhi_obj );
  }
  // == . END PUBLIC METHOD /_00HelpFn/ ===============================

  // == BEGIN PUBLIC METHOD /_01InstallFn/ ============================
  function _01InstallFn ( arg_list ) {
    var
      install_fn = require( fqBinDirname + '/xhi_01' ),
      xhi_obj    = makeXhiObj( arg_list )
      ;

    install_fn.call( xhi_obj );
  }
  // == . END PUBLIC METHOD /_01InstallFn/ ============================

  // == BEGIN PUBLIC METHOD /_02SetupFn/ ==============================
  // Purpose   : Delete, copies, and patches files. Install commit hook.
  // Example   : xhi_tool 02
  // Returns   : boolean true on success
  // Throws    : none
  // Method    :
  //   1. Count down from end of array with last_idx
  //   2. Randomly pick element from between 0 and last_idx
  //   3. Swap pick element with last_idx element
  //
  //
  // Synopsis : Setup project using package.json as manifest.
  // Provides : Deletes, copies, and patches files. Install commit hook.
  //   1. Delete all vendor directories as directed by config.
  //      directories in bin, css, font, img, and js
  //   2. Copy assets from node_modules to vendor directories with the
  //      npm version appended to the names.
  //   3. Applies any patches (uglifyjs)
  //   4. Install the commit hook if git is detected
  //
  function _02SetupFn () {
    var setup_fn, xhi_obj;

    loadPostInstallFn();
    xhi_obj  = makeXhiObj();
    setup_fn = require( fqBinDirname + '/xhi_02' );
    setup_fn.call( xhi_obj );

    // flowObj.exec(
    //   function _02_00InitVarsFn () {
    //     logFn( appName + ' stage 02 Setup start.' );
    //     logFn( appName + ' stage 02 step 00: Init variables...' );
    //     process.chdir( fqProjDirname );
    //     checkExeList.call({ then_fn  : this, catch_fn : abortFn });
    //   },
    //   function _02_01ReadPkgFileFn () {
    //     logFn( appName + ' stage 02 step 01: Read package file...' );
    //     readPkgFileFn.call({ then_fn  : this, catch_fn : abortFn });
    //   },
    //   function _02_02RmVendorDirsFn () {
    //     logFn( appName + ' stage 02 step 02: Remove vendor directories...' );
    //     rmVendorDirsFn.call({ then_fn  : this, catch_fn : abortFn });
    //   },
    //   function _02_03CopyVendorFilesFn () {
    //     logFn( appName + ' stage 02 step 03: Deploy vendor assets...' );
    //     copyVendorFilesFn.call({ then_fn  : this, catch_fn : abortFn });
    //   },
    //   function _02_04PatchFilesFn () {
    //     logFn( appName + ' stage 02 step 04: Apply patches...' );
    //     patchFilesFn.call({ then_fn  : this, catch_fn : abortFn });
    //   },
    //   function _02_05CheckGitInstallFn () {
    //     logFn( appName + ' stage 02 step 05: Check for git installation...' );
    //     checkGitInstallFn.call({
    //       then_fn  : this,
    //       catch_fn : function () {
    //         logFn( 'Exiting without installing git commit hook.' );
    //         logFn( 'Please run this step again if you add git.' );
    //         process.chdir( fqOrigDirname );
    //         exitGoodFn();
    //       }
    //     });
    //   },
    //   function _02_06UnlinkHookFn () {
    //     logFn( appName + ' stage 02 step 06: Remove prior commit hook...' );
    //     unlinkHookFn.call({
    //       then_fn  : this,
    //       catch_fn : abortFn
    //     });
    //   },
    //   function _02_07LinkHookFn () {
    //     logFn( appName + ' stage 02 Add latest commit hook...' );
    //     linkHookFn.call({
    //       then_fn  : this,
    //       catch_fn : abortFn
    //     });
    //   },
    //   function _02_99FinishRunFn () {
    //     logFn( appName + ' stage 02 Setup finish.' );
    //     process.chdir( fqOrigDirname );
    //     exitGoodFn();
    //   }
    // );
  }
  // == . END PUBLIC METHOD /_02SetupFn/ ==============================
  function _03ShowArchFn () {}
  function _04DevPullFn  () {}
  function _05DevStartFn () {}
  function _06DevLintFn  () {}
  function _07DevTestFn  () {}
  // == BEGIN PUBLIC METHOD /_08DevCoverFn/ ==========================
  function _08DevCoverFn () {
    var cover_fn, xhi_obj;

    loadPostInstallFn();
    xhi_obj  = makeXhiObj();
    cover_fn = require( fqBinDirname + '/xhi_08' );
    cover_fn.call( xhi_obj );
  }
  // == . END PUBLIC METHOD /_08DevCoverFn/ ==========================
  function _09CommitFn () {}
  function _10BuildFn  () {}
  function _11PublishFn () {}
  function _12DevRestartFn () {}
  function _13DevStopFn () {}
  function _14DeployFn () {}
  function _15ProdStartFn () {}
  function _16ProdRestartFn () {}
  function _17ProdStopFn () {}
  function _18FetchInfoFn () {}
  function _19UninstallFn () {}
  function describeFn () {}

  commandTable = makeCommandTable([
    [ 'fn',              'alias_list',      'descr_str',  'help_list' ],
    [ _00HelpFn,       [ 'help'          ],  'Describe capability. '  ],
    [ _01InstallFn,    [ 'install'       ], 'Download+install npm mods',
      [ 'install', 'Runs npm install' ] ],
    [ _02SetupFn,      [ 'setup'         ], 'Patch+copy dev assets'     ],
    [ _03ShowArchFn,   [ 'design'        ], 'Show architecture docs'    ],
    [ _04DevPullFn,    [ 'dev_pull'      ], 'Pull from Git, sync libs'  ],
    [ _05DevStartFn,   [ 'dev_start'     ], 'Start local web services'  ],
    [ _06DevLintFn,    [ 'dev_lint'      ], 'Lint changed code'         ],
    [ _07DevTestFn,    [ 'dev_test'      ], 'Run regression tests'      ],
    [ _08DevCoverFn,   [ 'dev_cover'     ], 'Create coverage reports'   ],
    [ _09CommitFn,     [ 'dev_commit'    ], 'Save validate code to repo'],
    [ _10BuildFn,      [ 'build', 'make' ], 'Create app distribution'   ],
    [ _11PublishFn,    [ 'publish'       ], 'Upload to NPM, Coveralls'  ],
    [ _12DevRestartFn, [ 'dev_restart'   ], 'Cycle local web server'    ],
    [ _13DevStopFn,    [ 'dev_stop'      ], 'Stop development server'   ],
    [ _14DeployFn,     [ 'deploy'        ], 'Upload distro to servers'  ],
    [ _15ProdStartFn,  [ 'prod_start'    ], 'Start prod web services'   ],
    [ _16ProdRestartFn,[ 'prod_restart'  ], 'Cycle production process'  ],
    [ _17ProdStopFn ,  [ 'prod_stop'     ], 'Stop production process'   ],
    [ _18FetchInfoFn,  [ 'fetch_info'    ], 'Fetch prod info'           ],
    [ _19UninstallFn , [ 'uninstall'     ], 'Remove ' + appName         ]
  ]);
  // == BEGIN PUBLIC METHOD /mainFn/ ==================================
  // Purpose   : Parse command line and dispatch to requested command(s)
  function mainFn( arg_param_list ) {
    var
      param_list  = arg_param_list.slice(2),
      param0_str  = param_list[ 0 ],
      command_map, param_map, stage_fn, stage_list, xhi_obj
      ;

    // Abort if node version < minVersionInt
    checkNodeVersion();

    // Sepcial case: help
    // { range_list : [ 0,1,2,3,4 ]do, do_verbose : true }
    if ( param0_str === 'help' || Number( param0_str ) === 0 ) {
      param_list.shift();
      param_map   = makeParamMap( param_list );
      command_map = getTableRowMap( 0 );
      xhi_obj     = makeXhiObj({
        catch_fn    : abortFn,
        command_map : command_map,
        next_fn     : exitFn,
        param_map   : param_map
      });
      stage_fn = require( fqBinDirname + '/xhi_00' ),
      stage_fn.call( xhi_obj );
    }

    // TODO: Walk backward through range and bind functions.
    // The last function should have next_fn set to exitFn.
    // The second-to-last function should have next_fn set to 
    //   the last function.
    // The third-to-last function should have next_fn set to
    //   the second-to-last function, etc.
    //
    // param_map = makeParamMap( param_list );
    // param_map.range_list.forEach( function ( stage_idx, idx ) {
    //   var stage_id = String( stage_idx );
    //   if ( stage_id.length === 1 ) {
    //     stage_id = '0' + stage_id;
    //   }
    //
    //   command_map = getTableRowMap( stage_id );
    //   if ( ! command_map ) {
    //     abortFn( 'Cannot find stage ' + stage_id );
    //   }
    //   exit_int = command_map.fn.call( 
    //     command_map, param_map.do_verbose
    //   );
    // });
  }
  // == . END PUBLIC METHOD /mainFn/ ==================================

  mainFn( argList );
// == . END SCRIPT xhi - the hi_score cli tool ========================
