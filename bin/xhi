#!/usr/bin/node
/* vim: set ft=javascript: */
/*
 * Purpose   : Run hi_score lifecycle tools
 * Example   : See xhi help (_00HelpFn)
 * Author    : Michael S. Mikowski - mike.mikowski@gmail.com
 *
*/
/*jslint node : true */
/*global Promise */

// TODO move all npm script to xhi helper
//
// Stages correlated wth npm
// "00": "bin/xhi 00",
// "00_.": "=== HELP",
// "01": "bin/xhi 01",
// "01_.": "=== INSTALL",
// "01_a": "...node preinstall: Run BEFORE the pkg is installed",
// "02": "bin/xhi 02",
// "02_.": "=== SETUP",
// "02_a": "...node install, postinstall: Run AFTER the pkg is installed.",
// "03": "bin/xhi 03",
// "03_.": "=== DESIGN",
// "03__": "...synonym cat /doc/spa-arch.md",
// "04": "bin/xhi 04",
// "04_.": "=== DEVSERVER-START",
// "04_1": "...node start",
// "04_2": "...node poststart",
// "04_a": "...node prestart",
// "05": "bin/xhi 05",
// "05_.": "=== GIT PULL",
// "06": "bin/xhi 06",
// "06_.": "=== DEVELOP-LINT",
// "07": "bin/xhi 07",
// "07_.": "=== DEVELOP-TEST",
// "07_a": "...node pretest, test, posttest: Run by the npm test command.",
// "08": "bin/xhi 08",
// "08_.": "=== DEVELOP-COVERAGE",
// "09": "bin/xhi 09",
// "09_.": "=== DEVELOP-COMMIT",
// "09_1": "...node postversion: Run AFTER bumping the pkg version, and AFTER commit.",
// "09_a": "...node preversion: Run BEFORE bumping the pkg version.",
// "09_b": "...node version: Run AFTER bumping the pkg version, but BEFORE commit.",
// "10": "bin/xhi 10",
// "10_.": "=== BUILD",
// "10_a": "...node prepare: Run both BEFORE the pkg is packed and published, and on local npm install without any arguments (See below). This is run AFTER prepublish, but BEFORE prepublishOnly.",
// "11": "bin/xhi 11",
// "11_.": "=== PUBLISH",
// "11_1": "...node publish",
// "11_2": "...node postpublish: Run AFTER the pkg is published.",
// "11_a": "...node prepublish: Run BEFORE the pkg is packed and published, as well as on local npm install without any arguments. (See below)",
// "11_b": "...node prepublishOnly: Run BEFORE the pkg is prepared and packed, ONLY on npm publish. (See below.)",
// "12": "bin/xhi 12",
// "12_.": "=== DEVSERVER-RESTART",
// "12_1": "...node restart",
// "12_2": "...node postrestart",
// "12_3": "...node WARN: npm restart will run the stop and start scripts if no restart script is provided.",
// "12_a": "...node prerestart",
// "13": "bin/xhi 13",
// "13_.": "=== DEVSERVER-STOP",
// "13_1": "...node stop",
// "13_2": "...node poststop",
// "13_a": "...node prestop",
// "14": "bin/xhi 14",
// "14_.": "=== DEPLOY",
// "14_1": "...node postpack: Run AFTER the tarball has been generated and moved to its final destination.",
// "14_a": "...node preshrinkwrap, shrinkwrap, postshrinkwrap: Run by the npm shrinkwrap command.",
// "14_b": "...node prepack: run BEFORE a tarball is packed (on npm pack, npm publish, and when installing git dependencies)",
// "15": "bin/xhi 15",
// "15_.": "=== PRODSERVER-START",
// "16": "bin/xhi 16",
// "16_.": "=== PRODSERVER-RESTART",
// "17": "bin/xhi 17",
// "17_.": "=== PRODSERVER-STOP",
// "18": "bin/xhi 18",
// "18_.": "=== FEEDBACK",
// "19": "bin/xhi 19",
// "19_.": "=== UNINSTALL",
// "19_1": "...node preuninstall, uninstall: Run BEFORE the pkg is uninstalled.",
// "19_2": "...node postuninstall: Run AFTER the pkg is uninstalled.",
// == BEGIN SCRIPT xhi - the hi_score cli tool ========================
  // == BEGIN MODULE SCOPE VARIABLES ==================================
  'use strict';
  var
    // Import capabilities
    EventEmitter = require( 'events' ).EventEmitter,
    childProcObj = require( 'child_process' ),
    fsObj        = require( 'fs'            ),
    npmObj       = require( 'npm'           ),
    pathObj      = require( 'path'          ),
    utilObj      = require( 'util'          ),
    promiseObj   = Promise,

    execFn       = childProcObj.exec,
    makeSpawnObj = childProcObj.spawn,

    // Convert to promises using promisfy
    promisifyFn   = utilObj.promisify,
    makeStatProm  = promisifyFn( fsObj.stat ),

    // Assign nodejs builtins
    eventObj      = new EventEmitter(),
    fqAppFilename = __filename,
    fqBinDirname  = __dirname,

    // Get environment values
    appName       = pathObj.basename( fqAppFilename, '.js' ),
    argList       = process.argv,
    fqOrigDirname = process.cwd(), // or pathObj.resolve()
    versList      = process.versions.node.split('.'),

    // Set paths
    fqProjDirname   = pathObj.dirname( fqBinDirname ),
    fqGitDirname    = fqProjDirname   + '/.git',
    fqModuleDirname = fqProjDirname   + '/node_modules',
    fqPkgFilename   = fqProjDirname   + '/package.json',
    fqPatchFilename = fqProjDirname   + '/patch/uglify-js-3.0.21.patch',

    fqUglyDirname   = fqModuleDirname + '/uglifyjs',
    fqScopeFileStr  = fqUglyDirname   + '/lib/scope.js',

    // Set minimum Node verion number and init empty map
    minVersionInt  = 8,
    exePathMap     = {},

    // Set convenience vars
    __0 = 0,
    __1 = 1,

    // Declare curried functions
    abortFn, logFn, warnFn,

    // Declare config data
    fqHookFilename,  pkgMatrix,    setupMatrix,
    rawCommandTable, commandTable,

    // Declare after-install-variables
    LineReader, applyPatchFn,  flowObj, 
    mkdirpFn,   ncpFn,         rmDirFn,
    whichFn,    makeWhichProm, makeRmDirProm
    ;
  // == . END MODULE SCOPE VARIABLES ==================================

  // == BEGIN UTILITY METHODS =========================================
  function exitGoodFn () { process.exit( 0 ); }
  function exitBadFn  () { process.exit( 1 ); }

  // BEGIN utility /_outFn/
  // Purpose: provides abortFn, logFn, and warnFn
  function _outFn() {
    var
      context_map = this || {},
      method_str = context_map._method_str_ || 'log',
      prompt_str = context_map._prompt_str_ || appName + '-info> ',
      arg_list   = Array.from( arguments )
      ;

    arg_list.unshift( prompt_str );
    console[ method_str ].apply( null, arg_list );
    if ( context_map._cwd_name_ ) {
      process.chdir( context_map._cwd_name_ );
    }
    if ( context_map._do_abort ) { exitBadFn(); }
  }

  abortFn = _outFn.bind({
    _cwd_name_   : fqOrigDirname,
    _do_abort_   : true,
    _method_str_ : 'warn',
    _prompt_str_ : appName + '-abort> ',
  });
  logFn   = _outFn.bind();
  warnFn  = _outFn.bind({
    _method_str_ : 'warn',
    _prompt_str_ : appName + '-warn> '
  });
  // . END utility /_outFn/


  // BEGIN utility /makeCommandTable/
  function makeCommandTable ( raw_table ) {
    var
      row_count   = raw_table.length,
      head_row    = raw_table[0],
      field_count = head_row.length,

      solve_table = [],
      src_list, row_map, idx, jdx
      ;

    for ( idx = 1; idx < row_count; idx++ ) {
      src_list = raw_table[ idx ];
      row_map = { idx : idx };
      for ( jdx = 0; jdx < field_count; jdx++ ) {
        row_map[ head_row[ jdx ] ] = src_list[ jdx ];
      }
      solve_table.push( row_map );
    }
    return solve_table;
  }
  // . END utility /makeCommandTable/

  // BEGIN utility /filterByAlias/
  function filterByAlias ( map ) {
    return ( map.alias_list.indexOf( this ) > -1 );
  }
  // . END utility /filterByAlias/

  // BEGIN utility /getTableRow/
  function getTableRow ( row_id ) {
    var
      idx = parseInt( row_id, 10 ),
      filter_list
      ;

    if ( isNaN( idx ) ) {
      filter_list = commandTable.filter( filterByAlias, row_id );
    }
    else {
      filter_list = [ commandTable[ idx ] ];
    }
    return filter_list[ 0 ];
  }
  // . END utility /getTableRow/

  // BEGIN utlity /grepFileFn/
  function grepFileFn ( filename, pattern_str ) {
    return new Promise( function ( resolve_fn ) {
      var
        is_matched    = false,
        line_read_obj = new LineReader( filename, {skipEmptyLines:true })
        ;

      line_read_obj.on( 'error', abortFn );
      line_read_obj.on( 'line',  function ( line_str ) {
        if ( line_str.indexOf( pattern_str ) > -1 ) {
          is_matched = true;
          line_read_obj.close();
        }
      });
      line_read_obj.on( 'end', function () {
        resolve_fn( is_matched );
      });
    });
  }
  // . END utility /grepFileFn/

  // BEGIN utilities to return resolve and reject functions
  function makeRejectFuncFn ( reject_fn ) {
    return function ( error_data ) { reject_fn( error_data ); };
  }

  function makeResolveFuncFn ( resolve_fn ) {
    return function () { resolve_fn(); };
  }
  // . END utilities to return resolve and reject functions

  // BEGIN utility /copyPathFn/
  function copyPathFn( fq_src_path_str, fq_dest_path_str, do_dir_copy ) {
    if ( do_dir_copy ) {
      return new Promise( function ( resolve_fn, reject_fn ) {
        ncpFn( fq_src_path_str, fq_dest_path_str,
          function ( error_data ) {
            if ( error_data ) { return reject_fn(); }
            resolve_fn();
          }
        );
      });
    }

    return new Promise( function ( resolve_fn, reject_fn ) {
      var
        read_obj         = fsObj.createReadStream(  fq_src_path_str  ),
        write_obj        = fsObj.createWriteStream( fq_dest_path_str ),
        full_reject_fn  = makeRejectFuncFn(  reject_fn  ),
        full_resolve_fn = makeResolveFuncFn( resolve_fn )
        ;

      read_obj.on(  'error', full_reject_fn  );
      write_obj.on( 'error', full_reject_fn  );
      write_obj.on( 'close', full_resolve_fn );
      read_obj.pipe( write_obj );
    });
  }
  // . END utility /copyPathFn/

  // BEGIN utility /storePathFn/
  function storePathFn ( path_str ) {
    var
      context_map = this,
      exe_key = context_map.exe_key;

    if ( ! exe_key ) {
      abortFn( 'No key provided for ' + path_str );
    }
    exePathMap[ exe_key ] = path_str;
  }
  // . END utility /storePathFn/

  // BEGIN utility /patchIfNeededFn/
  function patchIfNeededFn ( is_check_found ) {
    var context_map = this;
    if ( is_check_found ) {
      logFn( 'Patch ' + context_map.relative_name + ' already applied.' );
    }
    else {
      applyPatchFn( context_map.relative_name );
      logFn( 'Applied patch ' + context_map.relative_name );
    }
  }
  // . END utility /patchIfNeededFn/

  // BEGIN utility /loadPostInstallfn/
  // Loads libraries after stage 01 (install) is complete
  function loadPostInstallFn () {
    LineReader   = require( 'line-by-line' );
    applyPatchFn = require( 'apply-patch'  ).applyPatch;
    flowObj      = require( 'flow'         ); 
    mkdirpFn     = require( 'mkdirp'       );
    ncpFn        = require( 'ncp'          ).ncp;
    rmDirFn      = require( 'rmdir'        );
    whichFn      = require( 'which'        );

    makeRmDirProm = promisifyFn( rmDirFn   );
    makeWhichProm = promisifyFn( whichFn   );
  }
  // . END utility /loadPostInstallFn/

  // BEGIN utility /checkExeList/
  function checkExeList () {
    var
      context_map  = this,
      exe_list     = [ 'git', 'patch' ],
      exe_count    = exe_list.length,
      promise_list = [],

      idx, exe_key, bound_fn, promise_obj;

    // Assign executable path vars
    for ( idx = 0; idx < exe_count; idx++ ) {
      exe_key     = exe_list[ idx ];
      bound_fn    = storePathFn.bind( { exe_key : exe_key });
      promise_obj = makeWhichProm( exe_key );
      promise_obj.then( bound_fn ).catch( abortFn );
      promise_list.push( promise_obj );
    }

    promiseObj.all( promise_list )
      .then(   context_map.then_fn )
      .catch( context_map.catch_fn )
      ;
  }
  // . END utility /checkExeList/

  // BEGIN utility /storePkgMapFn/
  function storePkgMapFn ( error_obj, json_str ) {
    var context_map = this;
    if ( error_obj ) { return abortFn( error_obj ); }
    pkgMatrix   = JSON.parse( json_str ) || [];
    setupMatrix = pkgMatrix.xhi_02_SetupMatrix;
    if ( ! setupMatrix ) {
      abortFn( 'xhi_02_SetupMatrix not set in package.json' );
    }
    context_map.then_fn();
  }
  // . END utility /storePkgMapFn/

  // BEGIN utility /readPkgFileFn/
  function readPkgFileFn () {
    var context_map = this;
    fsObj.readFile( fqPkgFilename, 'utf8',
    storePkgMapFn.bind( context_map ), abortFn );
  }
  // END utility /readPkgFileFn/

  // BEGIN utility /rmVendorDirsFn/
  function rmVendorDirsFn () {
    var
      context_map        = this,
      asset_group_table  = setupMatrix.asset_group_table,
      asset_group_count  = asset_group_table.length,
      promise_list       = [],

      idx, asset_group_map, fq_dest_dir_str, promise_obj
      ;

    for ( idx = 0; idx < asset_group_count; idx++ ) {
      asset_group_map = asset_group_table[ idx ] || {};
      fq_dest_dir_str = fqProjDirname + '/' + asset_group_map.dest_dir_str;
      mkdirpFn.sync( fq_dest_dir_str );

      promise_obj = makeRmDirProm( fq_dest_dir_str );
      promise_list.push( promise_obj );
    }

    promiseObj.all( promise_list )
      .then(  context_map.then_fn )
      .catch( context_map.catch_fn )
      ;
  }
  // . END utility /rmVendorDirsFn/

  // BEGIN utility /copyVendorFilesFn/
  function copyVendorFilesFn () {
    var
      context_map        = this,
      asset_group_table  = setupMatrix.asset_group_table || [],
      dev_dependency_map = pkgMatrix.devDependencies     || {},
      asset_group_count  = asset_group_table.length,
      promise_list       = [],

      idx, asset_group_map, asset_list, asset_count,
      fq_dest_dir_str, dest_ext_str, do_dir_copy,

      idj, asset_map, src_asset_name, src_dir_str,
      src_pkg_name, dest_vers_str, dest_name,
      fq_src_path_list, fq_src_path_str,
      fq_dest_path_str, promise_obj
      ;

    for ( idx = 0; idx < asset_group_count; idx++ ) {
      asset_group_map = asset_group_table[ idx ] || {};

      asset_list  = asset_group_map.asset_list   || [];
      asset_count = asset_list.length;

      dest_ext_str     = asset_group_map.dest_ext_str;
      do_dir_copy      = asset_group_map.do_dir_copy;
      fq_dest_dir_str  = fqProjDirname + '/'
        + asset_group_map.dest_dir_str;

      mkdirpFn.sync( fq_dest_dir_str );
      ASSET_MAP: for ( idj = 0; idj < asset_count; idj++ ) {
        asset_map      = asset_list[ idj ];
        src_asset_name = asset_map.src_asset_name;
        src_dir_str    = asset_map.src_dir_str || '';
        src_pkg_name   = asset_map.src_pkg_name;

        dest_vers_str  = dev_dependency_map[ src_pkg_name ];

        if ( ! dest_vers_str ) {
          logFn( 'WARN: package ' + src_pkg_name + ' not found.');
          continue ASSET_MAP;
        }
        dest_name = asset_map.dest_name || src_pkg_name;

        fq_dest_path_str = fq_dest_dir_str
          + '/' + dest_name + '-' + dest_vers_str;
        fq_src_path_list = [ fqModuleDirname, src_pkg_name, src_asset_name ];
        if ( src_dir_str ) { fq_src_path_list.splice( 2, 0, src_dir_str ); }

        fq_src_path_str = fq_src_path_list.join( '/' );

        if ( ! do_dir_copy ) {
          fq_dest_path_str += '.' + dest_ext_str;
        }
        promise_obj = copyPathFn(
          fq_src_path_str, fq_dest_path_str, do_dir_copy
        );
        promise_list.push( promise_obj );
      }
    }

    promiseObj.all( promise_list )
      .then(  context_map.then_fn  )
      .catch( context_map.catch_fn );
  }
  // . END utility /copyVendorFilesFn/

  // BEGIN utility /patchFilesFn/
  // This function requires CWD to be fqProjDirname
  function patchFilesFn () {
    var
      context_map      = this,
      patch_matrix     = setupMatrix.patch_matrix   || {},
      patch_dir_str    = patch_matrix.patch_dir_str || '',
      patch_map_list   = patch_matrix.patch_map_list|| [],
      patch_map_count  = patch_map_list.length,
      promise_list     = [],
      idx, patch_map, promise_obj,
      check_filename, patch_filename,
      bound_fn
      ;

    for ( idx = 0; idx < patch_map_count; idx++ ) {
      patch_map      = patch_map_list[ idx ];
      check_filename = patch_map.check_filename;
      patch_filename = patch_map.patch_filename;
      patch_map.relative_name = patch_dir_str + '/' + patch_filename;

      promise_obj    = grepFileFn( check_filename, patch_map.pattern_str );
      bound_fn       = patchIfNeededFn.bind( patch_map );
      promise_obj.then( bound_fn ).catch( abortFn );
      promise_list.push( promise_obj );
    }

    Promise.all( promise_list )
      .then(  context_map.then_fn  )
      .catch( context_map.catch_fn )
      ;
  }
  // . END utility /patchFilesFn/

  // BEGIN utility /checkGitInstallFn/
  function checkGitInstallFn () {
    var
      context_map = this,
      promise_obj = makeStatProm( fqGitDirname )
      ;

    promise_obj
      .then( function () {
        logFn( 'Git directory ' + fqGitDirname + ' found.');
        context_map.then_fn();
      })
      .catch( function () {
        logFn( 'Git directory ' + fqGitDirname + ' NOT found.');
        context_map.catch_fn();
      });
  }
  // . END utility /checkGitInstallFn/

  // BEGIN utility /unlinkHookFn/
  // This ignores any error
  function unlinkHookFn () {
    var context_map = this;
    fqHookFilename = fqProjDirname + '/.git/hooks/pre-commit';
    fsObj.unlink( fqHookFilename, context_map.then_fn );
  }
  // . END utility /unlinkHookFn/

  // BEGIN utility /linkHookFn/
  // This function requires CWD to be fqProjDirname
  function linkHookFn () {
    var context_map = this;
    fsObj.symlink(
      '../../bin/git-hook_pre-commit',
      fqHookFilename,
      function ( error_data ) {
        if ( error_data ) { abortFn( error_data ); }
        context_map.then_fn();
      }
    );
  }
  // . END utility /linkHookFn/
  // == END UTILITY METHODS ============================================

  // == BEGIN EVENT HANDLERS ===========================================
  // function makeBoundEmitFn ( signal_str ) {
  //   return function () { eventObj.emit( signal_str ); };
  // }
  // == . END EVENT HANDLERS ==========================================
  function makeXhiObj () {
    return {
      abortFn           : abortFn,
      appName           : appName,
      checkExeList      : checkExeList,
      checkGitInstallFn : checkGitInstallFn,
      copyVendorFilesFn : copyVendorFilesFn,
      exitGoodFn        : exitGoodFn,
      flowObj           : flowObj,
      fqOrigDirname     : fqOrigDirname,
      fqProjDirname     : fqProjDirname,
      linkHookFn        : linkHookFn,
      logFn             : logFn,
      makeSpawnObj      : makeSpawnObj,
      patchFilesFn      : patchFilesFn,
      readPkgFileFn     : readPkgFileFn,
      rmVendorDirsFn    : rmVendorDirsFn,
      unlinkHookFn      : unlinkHookFn,
      warnFn            : warnFn
    };
  }
  // == BEGIN PUBLIC METHOD /_00HelpFn/ ===============================
  function _00HelpFn () {
    var 
      help_fn = require( fqBinDirname + '/xhi_00' ),
      xhi_obj = makeXhiObj()
      ;

    help_fn.call( xhi_obj );
    
    // help_fn({
    //   abortFn    : abortFn,
    //   appName    : appName,
    //   exitGoodFn : exitGoodFn,
    //   logFn      : logFn,
    //   warnFn     : warnFn
    // });
    // var help_str = '\n'
    //   + '  Name      : ' + appName + '\n'
    //   + '  Purpose   : Run hi_score lifecycle tools\n'
    //   + '  Example   : xhi 00 # or xhi help\n'
    //   + '  Arguments : (positional)\n'
    //   + '    <range> || help <range> || help all\n\n'
    //   + '    <range> may be:\n'
    //   + '    1. A single stage number, e.g. 01.\n'
    //   + '    2. A list of stage numbers, e.g. 01 02 06.\n'
    //   + '    3. A range of stage numbers, e.g. 00 - 09.\n'
    //   + '    The life cycle number as presented below.\n'
    //   + '     The default is 00.\n'
    //   + '  More examples:\n'
    //   + '    ' + appName + ' help all      // Describe all stages\n'
    //   + '    ' + appName + ' help 01       // describe stage 01\n'
    //   + '    ' + appName + ' help 01 02 06 // describe 3 stages\n'
    //   + '    ' + appName + ' help 00 - 09  // describe 10 stages\n'
    //   + '    ' + appName + ' 01 02 06      // runs 3 stages\n'
    //   + '    ' + appName + ' 00 - 09       // run 10 stages\n\n'
    //   ;
    //
    // logFn( help_str );
    // exitGoodFn();
  }
  // == . END PUBLIC METHOD /_00HelpFn/ ===============================

  // == BEGIN PUBLIC METHOD /_01InstallFn/ ============================
  function _01InstallFn () {
    var 
      install_fn = require( fqBinDirname + '/xhi_01' ),
      xhi_obj    = makeXhiObj()
      ;

    install_fn.call( xhi_obj );
    
    // var context_obj, stream_obj;
    //
    // context_obj = this;
    // logFn( 'Install dependencies using "npm install"...' );
    //
    // stream_obj = makeSpawnObj( 'npm', ['install'] );
    // stream_obj.stdout.on( 'data', function ( data ) { logFn(  data.toString() ); } );
    // stream_obj.stderr.on( 'data', function ( data ) { warnFn( data.toString() ); } );
    // stream_obj.on( 'close',
    //   function ( exit_code ) {
    //     if ( exit_code === 0 ) {
    //       logFn( 'Success!' );
    //     }
    //     else {
    //       warnFn( 'The install did not work as expected.' );
    //       warnFn( 'Please run "npm install" to diagnose.' );
    //     }
    //     process.exit( exit_code );
    //   }
    // );
  }
  // == . END PUBLIC METHOD /_01InstallFn/ ============================

  // == BEGIN PUBLIC METHOD /_02SetupFn/ ==============================
  // Purpose   : Delete, copies, and patches files. Install commit hook.
  // Example   : xhi_tool 02
  // Returns   : boolean true on success
  // Throws    : none
  // Method    :
  //   1. Count down from end of array with last_idx
  //   2. Randomly pick element from between 0 and last_idx
  //   3. Swap pick element with last_idx element
  //
  //
  // Synopsis : Setup project using package.json as manifest.
  // Provides : Deletes, copies, and patches files. Install commit hook.
  //   1. Delete all vendor directories as directed by config.
  //      directories in bin, css, font, img, and js
  //   2. Copy assets from node_modules to vendor directories with the
  //      npm version appended to the names.
  //   3. Applies any patches (uglifyjs)
  //   4. Install the commit hook if git is detected
  //
  function _02SetupFn () {
    var setup_fn, xhi_obj;

    loadPostInstallFn();
    xhi_obj  = makeXhiObj();
    setup_fn = require( fqBinDirname + '/xhi_02' );
    setup_fn.call( xhi_obj );

    // flowObj.exec(
    //   function _02_00InitVarsFn () {
    //     logFn( appName + ' stage 02 Setup start.' );
    //     logFn( appName + ' stage 02 step 00: Init variables...' );
    //     process.chdir( fqProjDirname );
    //     checkExeList.call({ then_fn  : this, catch_fn : abortFn });
    //   },
    //   function _02_01ReadPkgFileFn () {
    //     logFn( appName + ' stage 02 step 01: Read package file...' );
    //     readPkgFileFn.call({ then_fn  : this, catch_fn : abortFn });
    //   },
    //   function _02_02RmVendorDirsFn () {
    //     logFn( appName + ' stage 02 step 02: Remove vendor directories...' );
    //     rmVendorDirsFn.call({ then_fn  : this, catch_fn : abortFn });
    //   },
    //   function _02_03CopyVendorFilesFn () {
    //     logFn( appName + ' stage 02 step 03: Deploy vendor assets...' );
    //     copyVendorFilesFn.call({ then_fn  : this, catch_fn : abortFn });
    //   },
    //   function _02_04PatchFilesFn () {
    //     logFn( appName + ' stage 02 step 04: Apply patches...' );
    //     patchFilesFn.call({ then_fn  : this, catch_fn : abortFn });
    //   },
    //   function _02_05CheckGitInstallFn () {
    //     logFn( appName + ' stage 02 step 05: Check for git installation...' );
    //     checkGitInstallFn.call({
    //       then_fn  : this,
    //       catch_fn : function () {
    //         logFn( 'Exiting without installing git commit hook.' );
    //         logFn( 'Please run this step again if you add git.' );
    //         process.chdir( fqOrigDirname );
    //         exitGoodFn();
    //       }
    //     });
    //   },
    //   function _02_06UnlinkHookFn () {
    //     logFn( appName + ' stage 02 step 06: Remove prior commit hook...' );
    //     unlinkHookFn.call({
    //       then_fn  : this,
    //       catch_fn : abortFn
    //     });
    //   },
    //   function _02_07LinkHookFn () {
    //     logFn( appName + ' stage 02 Add latest commit hook...' );
    //     linkHookFn.call({
    //       then_fn  : this,
    //       catch_fn : abortFn
    //     });
    //   },
    //   function _02_99FinishRunFn () {
    //     logFn( appName + ' stage 02 Setup finish.' );
    //     process.chdir( fqOrigDirname );
    //     exitGoodFn();
    //   }
    // );
  }
  // == . END PUBLIC METHOD /_02SetupFn/ ==============================
  function _03ShowArchFn () {}
  function _04DevPullFn  () {}
  function _05DevStartFn () {}
  function _06DevLintFn  () {}
  function _07DevTestFn  () {}
  // == BEGIN PUBLIC METHOD /_08DevCoverFn/ ==========================
  function _08DevCoverFn () {
    execFn( fqModuleDirname + '/.bin/istanbul cover -x \'**/vendor/**\' '
      + fqModuleDirname     + '/.bin/nodeunit '
      + fqProjDirname       + '/test/xhi_level_0.js',

      function ( error_data, stdout_str, stderr_str ) {
        if ( error_data ) {
          abortFn( error_data, stdout_str, stderr_str );
        }
        else { exitGoodFn(); }
      }
    );
  }
  // == . END PUBLIC METHOD /_08DevCoverFn/ ==========================
  function _09CommitFn () {}
  function _10BuildFn  () {
  }
  function _11PublishFn () {}
  function _12DevRestartFn () {}
  function _13DevStopFn () {}
  function _14DeployFn () {}
  function _15ProdStartFn () {}
  function _16ProdRestartFn () {}
  function _17ProdStopFn () {}
  function _18FetchInfoFn () {}
  function _19UninstallFn () {}
  function describeFn () {}

  commandTable = makeCommandTable([
    [ 'fn',              'alias_list',      'descr_str',  'help_list' ],
    [ _00HelpFn,       [ 'help'          ], 'Describe capability. '
      + 'Use "help help" for more detail.',
      [ '',              'Show stage and short info.',
        'long',          'Show stage and long general info.',
        'all',           'Show all stages available.',
        'install',       'Show stage and info on "install"',
        '01',            'same as above',
        'install deploy','show help for two steps',
        '01,14',         'same as above',
        '01-10',         'Show stages and info on 01 through 09',
        'install-build', 'Show stages and info from install to build',
      ]
    ],
    [ _01InstallFn,    [ 'install'       ], 'Download+install npm mods',
      [ 'install', 'Runs npm install' ] ],
    [ _02SetupFn,      [ 'setup'         ], 'Patch+copy dev assets'     ],
    [ _03ShowArchFn,   [ 'design'        ], 'Show architecture docs'    ],
    [ _04DevPullFn,    [ 'dev-pull'      ], 'Pull from Git, sync libs'  ],
    [ _05DevStartFn,   [ 'dev-start'     ], 'Start local web services'  ],
    [ _06DevLintFn,    [ 'dev-lint'      ], 'Lint changed code'         ],
    [ _07DevTestFn,    [ 'dev-test'      ], 'Run regression tests'      ],
    [ _08DevCoverFn,   [ 'dev-cover'     ], 'Create coverage reports'   ],
    [ _09CommitFn,     [ 'dev-commit'    ], 'Save validate code to repo'],
    [ _10BuildFn,      [ 'build', 'make' ], 'Create app distribution'   ],
    [ _11PublishFn,    [ 'publish'       ], 'Upload to NPM, Coveralls'  ],
    [ _12DevRestartFn, [ 'dev-restart'   ], 'Cycle local web server'    ],
    [ _13DevStopFn,    [ 'dev-stop'      ], 'Stop development server'   ],
    [ _14DeployFn,     [ 'deploy'        ], 'Upload distro to servers'  ],
    [ _15ProdStartFn,  [ 'prod-start'    ], 'Start prod web services'   ],
    [ _16ProdRestartFn,[ 'prod-restart'  ], 'Cycle production process'  ],
    [ _17ProdStopFn ,  [ 'prod-stop'     ], 'Stop production process'   ],
    [ _18FetchInfoFn,  [ 'fetch-info'    ], 'Fetch prod info'           ],
    [ _19UninstallFn , [ 'uninstall'     ], 'Remove ' + appName         ]
  ]);
  // == BEGIN PUBLIC METHOD /mainFn/ ==================================
  // Purpose   : Parse command line and dispatch to requested command(s)
  function mainFn( arg_param_list ) {
    var
      param_list  = arg_param_list.slice(2),
      param1_str  = param_list.shift(),
      abort_str,     command_row
      ;

    // DEBUG
    // warnFn( 'ARG LIST', [ command_id ].concat( param_list ) );
    // Abort if node version < minVersionInt
    if ( Number( versList[0] ) < minVersionInt ) {
      abort_str
        = 'NodeJS Version ' + versList.join('.') + ' is installed.\n'
        + 'As of ' + appName + '1.2 NodeJS v'
        + minVersionInt + ' is required.\n'
        + 'Please upgrade NodeJS and try again.'
        ;
      abortFn( abort_str );
    }

    command_row = getTableRow( param1_str ) || getTableRow( 0 );

    if ( ! command_row ) { abortFn( 'Cannot run!' ); }
    if ( command_row.idx === 0 ) { return _00HelpFn( param_list ); }
    command_row.fn( param_list );
  }
  // == . END PUBLIC METHOD /mainFn/ ==================================

  mainFn( argList );
// == . END SCRIPT xhi - the hi_score cli tool ========================
