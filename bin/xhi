#!/usr/bin/node
/* vim: set ft=javascript: */
/*
 * Purpose   : Run hi_score lifecycle tools
 * Example   : See xhi help
 * Author    : Michael S. Mikowski - mike.mikowski@gmail.com
 *
*/
/*jslint node : true */
/*global Promise */
// == BEGIN SCRIPT xhi - the hi_score cli life-stage tool =============
  // == BEGIN MODULE SCOPE VARIABLES ==================================
  'use strict';
  var
    childProcObj = require( 'child_process' ),
    fsObj        = require( 'fs'            ),
    npmObj       = require( 'npm'           ),

    pathObj      = require( 'path'          ),
    readlineObj  = require( 'readline'      ),
    utilObj      = require( 'util'          ),

    makeSpawnObj  = childProcObj.spawn,
    PromiseObj    = Promise,

    // Convert to promises using promisfy
    promisifyFn   = utilObj.promisify,

    // Assign nodejs builtins
    // eventObj      = new EventEmitter(),
    fqAppFilename = __filename,
    fqBinDirname  = __dirname,

    // Get environment values
    appName       = pathObj.basename( fqAppFilename, '.js' ),
    argList       = process.argv,
    fqOrigDirname = process.cwd(), // or pathObj.resolve()
    padName       = '    ' + appName,
    promptStr     = appName + '-info> ',
    versList      = process.versions.node.split('.'),

    // Set paths
    fqProjDirname   = pathObj.dirname( fqBinDirname ),

    fqLibDirname    = fqProjDirname   + '/lib',
    fqModuleDirname = fqProjDirname   + '/node_modules',
    fqPkgFilename   = fqProjDirname   + '/package.json',

    // Set minimum Node verion and init empty path map
    minVersionInt  = 8,
    binPathMap     = {},

    // Declare curried functions
    abortFn, exitFn, logFn, warnFn, makeTmpltStr,

    // Declare config data
    fqHookFilename,  pkgMatrix,    setupMatrix,
    commandTable,

    // Declare after-install-variables
    LineReader,    applyPatchFn,  exeCpeFn,
    flowObj,       mkdirpFn,      ncpFn,
    rmDirFn,       shellJsObj,    whichFn,

    makeWhichProm
    ;
  // == . END MODULE SCOPE VARIABLES ==================================

  // == BEGIN UTILITY METHODS =========================================
  // BEGIN utility /makeTmpltStr/
  // See js/xhi/01.util.js
  makeTmpltStr = (function () {
    function lookupFn ( ignore_str, lookup_name ) {
      var
        return_data  = this, // lookup_map
        lookup_list  = lookup_name.split( '.' ),
        lookup_count = lookup_list.length,
        idx, key_name
      ;

      for ( idx = 0; idx < lookup_count; idx++ ) {
        key_name = lookup_list[ idx ];
        return_data = ( return_data && return_data[ key_name ] );
      }
      return String( return_data ) || '';
    }

    function mainFn ( arg_map ) {
      // noinspection Annotator
      var
        map        = arg_map || {},
        input_str  = map._input_str_  || '',
        lookup_map = map._lookup_map_ || {},

        tmplt_rx   = /{{([^}]*[^}]+[^}]*)\}\}/g,
        bound_fn   = lookupFn.bind( lookup_map )
      ;

      return input_str.replace( tmplt_rx, bound_fn );
    }
    return mainFn;
  }());
  // . END utility /makeTmpltStr/

  // BEGIN utility /makeRightPadStr/
  function makeRightPadStr ( arg_str, arg_count ) {
    var
      delta_count = arg_count - arg_str.length,
      delta_list  = []
      ;

    delta_list.length = delta_count > 0 ? delta_count : 0;
    return arg_str + delta_list.join(' ');
  }
  // . END utility /makeRightPadStr/

  // BEGIN utility /_outFn/
  // Purpose: provides abortFn, exitFn, logFn, and warnFn
  function _outFn() {
    var
      ctx_obj    = this || {},
      method_str = ctx_obj.method_str || 'log',
      prompt_str = ctx_obj.prompt_str || promptStr,
      arg_list   = Array.from( arguments )
      ;

    if ( arg_list.length > 0 ) {
      arg_list.unshift( prompt_str );
      console[ method_str ].apply( null, arg_list );
    }
    if ( ctx_obj.cd_name ) {
      process.chdir( ctx_obj.cd_name );
    }
    if ( ctx_obj.do_abort ) { process.exit( 1 ); }
    if ( ctx_obj.do_exit  ) { process.exit( 0 ); }
  }
  abortFn = _outFn.bind({
    cd_name      : fqOrigDirname,
    do_abort     : true,
    method_str : 'warn',
    prompt_str : appName + '-abort>'
  });
  exitFn = _outFn.bind({
    cd_name   : fqOrigDirname,
    do_exit    : true,
    prompt_str : appName + '-exit>'
  });
  logFn   = _outFn.bind({});
  warnFn  = _outFn.bind({
    method_str : 'warn',
    prompt_str : appName + '-warn>'
  });
  // . END utility /_outFn/

  // BEGIN utility /askFn/
  // Purpose: Wrap readObj question with prompt
  //
  function askFn ( ask_str, response_fn ) {
    var read_obj = readlineObj.createInterface({
      input  : process.stdin,
      output : process.stdout
    });
    read_obj.question( promptStr + ask_str,
      function ( response_str ) {
      //  TODO: 2017-08-22 mmikowski crit: We must figure out how
      //  to disassociate this input and allow it to "pass through"
      //  to child processes.
        read_obj = null;
        response_fn( response_str );
      }
    );
  }
  // . END utilities /askFn/

  // BEGIN utility /makeCommandTable/
  // Purpose: Create data structure to look up command details
  //
  function makeCommandTable ( raw_table ) {
    var
      head_list   = raw_table[ 0 ],
      head_count  = head_list.length,
      prefix_str  = '\n' + promptStr + '      ',
      solve_table = [],
      raw_count   = raw_table.length,

      idx, row_list, solve_id, solve_map,
      jdx, field_key, field_data, solve_str
      ;

    ROW: for ( idx = 1; idx < raw_count; idx++ ) {
      row_list = raw_table[ idx ];
      solve_id   = String( idx - 1 );
      if ( solve_id.length < 2 ) { solve_id = '0' + solve_id; }
      solve_map = { id : solve_id, idx : idx - 1  };

      FIELD: for ( jdx = 0; jdx < head_count; jdx++ ) {
        field_key  = head_list[ jdx ];
        field_data = row_list[  jdx ];
        if ( field_key.match( /_str$/ ) ) {

          // Join array into multi-line string
          if ( Array.isArray( field_data ) ) {
            solve_str = prefix_str + field_data.join( prefix_str );
          }
          else {
            solve_str = String( field_data );
          }

          // Template replace
          solve_str = makeTmpltStr( {
            _input_str_  : solve_str,
            _lookup_map_ : {
              appName : appName,
              padName : padName
            }
          } );
          solve_map[ field_key ] = solve_str;
          continue FIELD;
        }
        solve_map[ field_key ] = field_data;
      }
      solve_table.push( solve_map );
    }
    return solve_table;
  }
  // . END utility /makeCommandTable/

  // BEGIN utility /filterByAlias/
  function filterByAlias ( map ) {
    return ( map.alias_list.indexOf( this ) > -1 );
  }
  // . END utility /filterByAlias/

  // BEGIN utility /getCommandMap/
  function getCommandMap ( row_id ) {
    var
      idx = parseInt( row_id, 10 ),
      filter_list
      ;

    if ( isNaN( idx ) ) {
      filter_list = commandTable.filter( filterByAlias, row_id );
    }
    else {
      filter_list = [ commandTable[ idx ] ];
    }
    return filter_list[ 0 ];
  }
  // . END utility /getCommandMap/

  // BEGIN utility /makePrefixStr/
  function makePrefixStr ( command_map ) {
    // noinspection MagicNumberJS
    return appName + ' Stage ' + command_map.id + ' '
      + makeRightPadStr( command_map.alias_list[ 0 ], 12 ) + ': '
      ;
  }
  // . END utility /makePrefixStr/

  // BEGIN utility /makeParamMap/
  // Purpose   : Process command line arguments
  // Example   : makeParamMap( [ 'help', '1', '-v' ] )
  //   returns : { do_verbose: true, range_str : '1',
  //               stage_list : [ <commandRowHelp> ] }
  // Example   : makeParamMap( [ '1', '-v' ] )
  //   returns : { do_verbose: true, range_str : '1'
  //               stage_list : [ <commandRow1> ] }
  // Arguments : (positional)
  //   0) stage_list - list of command line arguments and switches
  //   1) skip_idx   - skip this number of arguments (not switches)
  // Returns   :  An object as follows:
  //   { do_verbose : <true|false>,
  //     range_str  : <cli_range_provided>,
  //     stage_list : [  <commandRow0>, <commandTableRow1, ...  ]
  //   }
  function makeParamMap ( param_list, arg_skip_idx ) {
    var
      arg_count  = 0,
      skip_idx   = arg_skip_idx || 0,

      do_verbose = false,
      range_str  = '',
      stage_list = null,

      edge_list, temp_list
      ;

    param_list.forEach( function ( str, ignore_idx ) {
      var i, first_map, middle_map, last_map, first_idx, last_idx;
      if ( str === '-v' ) {
        do_verbose = true;
        return;
      }

      // skip range list if already defined
      if ( stage_list ) { return true; }

      if ( str.match(/-/) || str === 'all' ) {
        if ( arg_count < skip_idx ) {
          arg_count++;
          return;
        }

        edge_list = str === 'all'
          ? [ 0, commandTable.length - 1 ]
          : str.split( '-', 2 );

        first_map = getCommandMap( edge_list[ 0 ] );
        last_map  = getCommandMap( edge_list[ 1 ] );
        if ( ! first_map ) {
          return warnFn( 'Range stage ' + edge_list[ 0 ] + ' is invalid' );
        }
        if ( ! last_map ) {
          return warnFn( 'Range stage ' + edge_list[ 1 ] + ' is invalid' );
        }
        if ( first_map.idx > last_map.idx ) {
          return warnFn(
            'Range start start ' + edge_list[ 0 ]
            + ' exceeds stage end ' + edge_list[ 1 ]
          );
        }

        temp_list = [ first_map ];

        first_idx = first_map.idx + 1;
        last_idx  = last_map.idx  - 1;

        for ( i = first_idx; i <= last_idx; i++ ) {
          middle_map = getCommandMap( i );
          if ( ! middle_map ) { return; }
          temp_list.push( middle_map );
        }
        if ( last_map !== first_map ) {
          temp_list.push( last_map );
        }

        range_str  = str;
        stage_list = temp_list;
        return;
      }

      if ( str.match(/,/) ) {
        if ( arg_count < skip_idx ) {
          arg_count++;
          return;
        }
        edge_list = str.split(',');
        temp_list = [];
        edge_list.forEach( function ( data, ignore_idx ) {
          middle_map = getCommandMap( data );
          if ( ! middle_map ) { return; }
          temp_list.push( middle_map );
        });

        range_str  = str;
        stage_list = temp_list;
        return;
      }

      if ( arg_count < skip_idx ) {
        arg_count++;
        return;
      }
      middle_map = getCommandMap( str );
      if ( ! middle_map ) { return; }

      range_str  = str;
      stage_list = [ middle_map ];
    });

    return {
      do_verbose : do_verbose,
      range_str  : range_str,
      stage_list : stage_list || []
    };
  }
  // . END utility /makeParamMap/

  // BEGIN utlity /grepFileFn/
  // Purpose : Return list of lines in a file that match a pattern
  function grepFileFn ( filename, pattern_str ) {
    return new PromiseObj ( function ( resolve_fn, catch_fn ) {
      var
        line_read_obj = new LineReader( filename, {skipEmptyLines:true }),
        pattern_rx    = new RegExp( pattern_str ),
        match_list    = []
        ;

      line_read_obj.on( 'error', catch_fn );
      line_read_obj.on( 'line',  function ( line_str ) {
        if ( line_str.match( pattern_rx ) ) {
          match_list.push( line_str );
        }
      });
      line_read_obj.on( 'end', function () {
        resolve_fn( match_list );
      });
    });
  }
  // . END utility /grepFileFn/

  // BEGIN utility /copyPathFn/
  function copyPathFn( fq_src_path_str, fq_dest_path_str, do_dir_copy ) {
    if ( do_dir_copy ) {
      return new PromiseObj ( function ( resolve_fn, reject_fn ) {
        ncpFn( fq_src_path_str, fq_dest_path_str,
          function ( error_data ) {
            if ( error_data ) { return reject_fn(); }
            resolve_fn();
          }
        );
      });
    }

    return new PromiseObj ( function ( resolve_fn, reject_fn ) {
      var
        read_obj = fsObj.createReadStream(  fq_src_path_str  ),
        write_obj= fsObj.createWriteStream( fq_dest_path_str );

      read_obj.on(  'error', reject_fn  );
      write_obj.on( 'error', reject_fn  );
      write_obj.on( 'close', resolve_fn );
      read_obj.pipe( write_obj );
    });
  }
  // . END utility /copyPathFn/

  // BEGIN utility /storePathFn/
  function storePathFn ( path_str ) {
    var
      ctx_obj = this,
      bin_key = ctx_obj.bin_key;

    if ( ! bin_key ) {
      abortFn( 'No key provided for ' + path_str );
    }
    binPathMap[ bin_key ]  = path_str;
  }
  // . END utility /storePathFn/

  // BEGIN utility /loadPostInstallfn/
  // Loads libraries after stage 01 (install) is complete
  function loadLibsFn () {
    LineReader   = require( 'line-by-line' );
    applyPatchFn = require( 'apply-patch'  ).applyPatch;
    exeCpeFn     = require( 'execpe'       );
    flowObj      = require( 'flow'         );
    mkdirpFn     = require( 'mkdirp'       );
    ncpFn        = require( 'ncp'          ).ncp;
    rmDirFn      = require( 'rmdir'        );
    shellJsObj   = require( 'shelljs'      );
    whichFn      = require( 'which'        );
    makeWhichProm = promisifyFn( whichFn   );
  }
  // . END utility /loadLibsFn/

  // BEGIN utility /checkBinListFn/
  function checkBinListFn () {
    var
      ctx_obj      = this,
      exe_list     = [ 'git', 'patch' ],
      exe_count    = exe_list.length,
      promise_list = [],

      idx, bin_key, bound_fn, promise_obj;

    // Assign executable path vars
    for ( idx = 0; idx < exe_count; idx++ ) {
      bin_key     = exe_list[ idx ];
      bound_fn    = storePathFn.bind( { bin_key : bin_key });
      promise_obj = makeWhichProm( bin_key );
      promise_obj.then( bound_fn ).catch( abortFn );
      promise_list.push( promise_obj );
    }

    PromiseObj.all( promise_list )
      .then(  ctx_obj.then_fn  )
      .catch( ctx_obj.catch_fn )
      ;
  }
  // . END utility /checkBinListFn/

  // BEGIN utility /checkNodeVersionFn/
  function checkNodeVersionFn () {
    var abort_str;
    if ( Number( versList[0] ) < minVersionInt ) {
      abort_str
        = 'NodeJS Version ' + versList.join('.') + ' is installed.\n'
        + 'As of ' + appName + '1.2 NodeJS v'
        + minVersionInt + ' is required.\n'
        + 'Please upgrade NodeJS and try again.'
        ;
      abortFn( abort_str );
    }
  }
  // . END utility /checkNodeVersionFn/

  // BEGIN utility /storePkgMapFn/
  function storePkgMapFn ( error_obj, json_str ) {
    var ctx_obj = this;
    if ( error_obj ) { return ctx_obj.catch_fn( error_obj ); }
    pkgMatrix   = JSON.parse( json_str ) || {};
    setupMatrix = pkgMatrix.xhi_02_SetupMatrix;
    ctx_obj.then_fn();
  }
  // . END utility /storePkgMapFn/

  // BEGIN utility /copyVendorFilesFn/
  // TODO mmikowski 2017-08-18: move this to xhi_02
  function copyVendorFilesFn () {
    var
      ctx_obj            = this,
      asset_group_table  = setupMatrix.asset_group_table || [],
      dev_dependency_map = pkgMatrix.devDependencies     || {},
      asset_group_count  = asset_group_table.length,
      promise_list       = [],

      idx, asset_group_map, asset_list, asset_count,
      fq_dest_dir_str, dest_ext_str, do_dir_copy,

      idj, asset_map, src_asset_name, src_dir_str,
      src_pkg_name, dest_vers_str, dest_name,
      fq_src_path_list, fq_src_path_str,
      fq_dest_path_str, promise_obj
      ;

    for ( idx = 0; idx < asset_group_count; idx++ ) {
      asset_group_map = asset_group_table[ idx ] || {};

      asset_list  = asset_group_map.asset_list   || [];
      asset_count = asset_list.length;

      dest_ext_str     = asset_group_map.dest_ext_str;
      do_dir_copy      = asset_group_map.do_dir_copy;
      fq_dest_dir_str  = fqProjDirname + '/'
        + asset_group_map.dest_dir_str;

      mkdirpFn.sync( fq_dest_dir_str );
      ASSET_MAP: for ( idj = 0; idj < asset_count; idj++ ) {
        asset_map      = asset_list[ idj ];
        src_asset_name = asset_map.src_asset_name;
        src_dir_str    = asset_map.src_dir_str || '';
        src_pkg_name   = asset_map.src_pkg_name;

        dest_vers_str  = dev_dependency_map[ src_pkg_name ];

        if ( ! dest_vers_str ) {
          logFn( 'WARN: package ' + src_pkg_name + ' not found.');
          continue ASSET_MAP;
        }
        dest_name = asset_map.dest_name || src_pkg_name;

        fq_dest_path_str = fq_dest_dir_str
          + '/' + dest_name + '-' + dest_vers_str;
        fq_src_path_list = [ fqModuleDirname, src_pkg_name, src_asset_name ];
        if ( src_dir_str ) { fq_src_path_list.splice( 2, 0, src_dir_str ); }

        fq_src_path_str = fq_src_path_list.join( '/' );

        if ( ! do_dir_copy ) {
          fq_dest_path_str += '.' + dest_ext_str;
        }
        promise_obj = copyPathFn(
          fq_src_path_str, fq_dest_path_str, do_dir_copy
        );
        promise_list.push( promise_obj );
      }
    }

    PromiseObj.all( promise_list )
      .then(  ctx_obj.then_fn  ).catch( ctx_obj.catch_fn );
  }
  // . END utility /copyVendorFilesFn/

  // BEGIN utility /unlinkHookFn/
  // TODO mmikowski 2017-08-18: move this to xhi_02
  // This ignores any error
  function unlinkHookFn () {
    var ctx_obj = this;
    fqHookFilename = fqProjDirname + '/.git/hooks/pre-commit';
    fsObj.unlink( fqHookFilename, ctx_obj.then_fn );
  }
  // . END utility /unlinkHookFn/

  // BEGIN utility /linkHookFn/
  // This function requires CWD to be fqProjDirname
  // TODO mmikowski 2017-08-18: move this to xhi_02
  function linkHookFn () {
    var ctx_obj = this;
    fsObj.symlink(
      '../../bin/git-hook_pre-commit',
      fqHookFilename,
      function ( error_data ) {
        if ( error_data ) { abortFn( error_data ); }
        ctx_obj.then_fn();
      }
    );
  }
  // . END utility /linkHookFn/
  // == END UTILITY METHODS ============================================

  // == BEGIN EVENT HANDLERS ===========================================
  // function makeBoundEmitFn ( signal_str ) {
  //   return function () { eventObj.emit( signal_str ); };
  // }
  // == . END EVENT HANDLERS ==========================================

  // BEGIN utility /makeXhiObj/
  // Purpose: Create object to provide as context to lib functions
  //  nextFn and catchFn are defaults.
  //
  function makeXhiObj () {
    return {
      appName         : appName,        // Applicaiton name
      askFn           : askFn,          // Read line with prompt
      catchFn         : abortFn,        // Fn for error
      commandMap      : null,           // Command map of lib to exec
      fqBinDirname    : fqBinDirname,   // Full path of bin scripts
      fqOrigDirname   : fqOrigDirname,  // Full path of PWD
      fqPkgFilename   : fqPkgFilename,  // Full path to package.json
      fqProjDirname   : fqProjDirname,  // Full path of root project dir
      fsObj           : fsObj,          // File system object
      getCommandMap   : getCommandMap,  // Get command map by id or index
      loadLibsFn      : loadLibsFn,     // Load libs after stage 1
      logFn           : logFn,          // Log to console
      makePrefixStr   : makePrefixStr,  // Fn for stage prefix
      makeRightPadStr : makeRightPadStr,// Pad string right
      makeSpawnObj    : makeSpawnObj,   // Object create spawned proc
      makePostObj     : makePostObj,     // Get utils after stage 1
      nextFn          : exitFn,         // Fn for success
      npmObj          : npmObj,         // Npm API object
      paramMap        : null,           // Parameters per CLI input
      promisifyFn     : promisifyFn,    // Promisify from utils
      pkgMatrix       : pkgMatrix,      // package.json content
      warnFn          : warnFn          // Warn to console
    };
  }
  // . END utility /makeXhiObj/

  // BEGIN utility /makePostObj/
  // Purpose: Creates resource map for modules available
  //   only after npm install.
  //
  function makePostObj () {
    return {
      applyPatchFn      : applyPatchFn,
      binPathMap        : binPathMap,        // --  ?
      checkBinListFn    : checkBinListFn,    // 02 setup
      copyVendorFilesFn : copyVendorFilesFn, // 02 setup
      exeCpeFn          : exeCpeFn,          // --  ?
      flowObj           : flowObj,           // 02 setup
      fqModuleDirname   : fqModuleDirname,   // 02 setup
      grepFileFn        : grepFileFn,        // 02 setup, 06 lint
      linkHookFn        : linkHookFn,        // 02 setup
      rmDirFn           : rmDirFn,           // 02 setup
      unlinkHookFn      : unlinkHookFn       // 02 setup
    };
  }
  // . END utility /makePostObj/

  // == BEGIN PUBLIC METHOD /mainFn/ ==================================
  // Purpose   : Parse command line and dispatch to requested command(s)
  function mainFn() {
    var
      param_list = argList.slice( 2 ),
      exec_list  = [],

      command_map, param_map,   stage_list,
      xhi_obj,     stage_idx,
      stage_fn,    bound_fn
      ;

    // Create command table from config
    commandTable = makeCommandTable( pkgMatrix.xhi_commandTable );
    param_map    = makeParamMap( param_list );
    stage_list   = param_map.stage_list;


    // Abort if node version < minVersionInt
    checkNodeVersionFn();
    command_map = stage_list[ 0 ];

    // Make new xhi_obj as context for lib function
    xhi_obj = makeXhiObj();

    // Special case: help
    if ( ! command_map
      || param_map.range_str === ''
      || param_map.range_str.match(/^0+$/)
      || param_map.range_str === 'help'
    ) {
      command_map = getCommandMap( 0 );
      xhi_obj.commandMap = command_map;
      xhi_obj.paramMap   = makeParamMap( param_list, 1 );
      xhi_obj.doListShow = true;
      stage_fn = require( fqLibDirname + '/xhi_00.js' );
      return stage_fn.call( xhi_obj );
    }

    // Begin exec standard stage list
    // Walk backward through list and bind functions.
    // The last function should have nextFn set to exit function.
    // The second-to-last function should have nextFn set to
    //   the last function.
    // The third-to-last function should have nextFn set to
    //   the second-to-last function, etc.
    //
    xhi_obj.nextFn = function _nextFn () {
      exitFn( 'Process range ' + param_map.range_str + ': Success');
    };

    stage_idx = stage_list.length - 1;
    while ( stage_idx > -1 ) {
      // Set commandMap, paramMap in context object
      command_map = stage_list[ stage_idx ];
      xhi_obj.commandMap = command_map;
      xhi_obj.paramMap   = param_map;

      // Load library ( TODO load preq_list? )
      stage_fn = require( fqLibDirname + '/xhi_' + command_map.id + '.js' );

      // Build exec chain
      bound_fn = stage_fn.bind( xhi_obj );
      exec_list.push( bound_fn );

      // Make new context object and set catchFn, nextFn
      if ( stage_idx > 0 ) {
        xhi_obj = makeXhiObj();
        xhi_obj.nextFn  = bound_fn;
      }
      stage_idx--;
    }
    logFn( 'Process range ' + param_map.range_str + ': Start');
    if ( bound_fn ) { return bound_fn(); }
    // End exec standard stage list
  }
  // == . END PUBLIC METHOD /mainFn/ ==================================

  // == BEGIN INITIALIZE SCRIPT =======================================
  // TODO 2017-08-23 mmikowski warn: add this info to package.json
  // The stages are configured via package.json but
  // since JSON does not allow comments we have added them here.
  // We may add this back as notes inside json like so:
  // "00__" : "help"
  // Stages correlated wth npm
  // === 00 'help'
  // "00": "bin/xhi 00",
  // "00_.": "=== HELP",
  // === 01 'install'
  // "01": "bin/xhi 01",
  // "01_.": "=== INSTALL",
  // "01_a": "...node preinstall: Run BEFORE the pkg is installed",
  // === 02 'setup'
  // "02": "bin/xhi 02",
  // "02_.": "=== SETUP",
  // "02_a": "...node install, postinstall: Run AFTER the pkg is installed.",
  // === 03 'design'
  // "03": "bin/xhi 03",
  // "03__": "...synonym cat /doc/spa-arch.md",
  // === 04 'dev_pull'
  // "04": "bin/xhi 04",
  // === 05 'dev_upgrade'
  // "05": "bin/xhi 05"
  // "05__": "Upgrade packages in package.json"
  // === 06 'dev_start'
  // "06": "bin/xhi 06",
  // "06_1": "...node start",
  // "06_2": "...node poststart",
  // "06_a": "...node prestart",
  // === 07 'dev_lint'
  // "07": "bin/xhi 07",
  // === 08 'dev_test'
  // "08": "bin/xhi 08",
  // "08_a": "...node pretest, test, posttest: Run by the npm test command.",
  // === 09 'dev_cover'
  // "09": "bin/xhi 09",
  // === 10 'dev_commit'
  // "10": "bin/xhi 10",
  // "10_1": "...node postversion: Run AFTER bumping the pkg version, and AFTER commit.",
  // "10_a": "...node preversion: Run BEFORE bumping the pkg version.",
  // "10_b": "...node version: Run AFTER bumping the pkg version, but BEFORE commit.",
  // === 11 'build', 'make'
  // "11": "bin/xhi 11",
  // "11_a": "...node prepare: Run both BEFORE the pkg is packed and published, and on local npm install without any arguments (See below). This is run AFTER prepublish, but BEFORE prepublishOnly.",
  // === 12 'publish'
  // "12": "bin/xhi 12",
  // "12_1": "...node publish",
  // "12_2": "...node postpublish: Run AFTER the pkg is published.",
  // "12_a": "...node prepublish: Run BEFORE the pkg is packed and published, as well as on local npm install without any arguments. (See below)",
  // "12_b": "...node prepublishOnly: Run BEFORE the pkg is prepared and packed, ONLY on npm publish. (See below.)",
  // === 13 'dev_restart'
  // "13": "bin/xhi 13",
  // "13_1": "...node restart",
  // "13_2": "...node postrestart",
  // "13_3": "...node WARN: npm restart will run the stop and start scripts if no restart script is provided.",
  // "13_a": "...node prerestart",
  // === 14 'dev_stop'
  // "14": "bin/xhi 14",
  // "14_1": "...node stop",
  // "14_2": "...node poststop",
  // "14_a": "...node prestop",
  // === 15 'deploy'
  // "15_.": "=== DEPLOY",
  // "15_1": "...node postpack: Run AFTER the tarball has been generated and moved to its final destination.",
  // "15_a": "...node preshrinkwrap, shrinkwrap, postshrinkwrap: Run by the npm shrinkwrap command.",
  // "15_b": "...node prepack: run BEFORE a tarball is packed (on npm pack, npm publish, and when installing git dependencies)",
  // === 16 'prod_start'
  // "16": "bin/xhi 16",
  // === 17 'prod_restart'
  // "17": "bin/xhi 17",
  // === 18 'prod_stop'
  // "18": "bin/xhi 18",
  // === 19 'fetch_info' (feedback)
  // "19": "bin/xhi 19", (uninstall)
  // === -1 'uninstall'
  // "-1_.": "=== UNINSTALL",
  // "-1_1": "...node preuninstall, uninstall: Run BEFORE the pkg is uninstalled.",
  // "-1_2": "...node postuninstall: Run AFTER the pkg is uninstalled.",

  // Read package.json and then proceed to parse arguments
  fsObj.readFile(
    fqPkgFilename, 'utf8', storePkgMapFn.bind({
      catch_fn : abortFn,
      then_fn  : mainFn
    })
  );
  // == . END INITIALIZE SCRIPT =======================================
// == . END SCRIPT xhi - the hi_score cli life-stage tool =============
