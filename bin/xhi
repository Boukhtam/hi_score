#!/usr/bin/node
/* vim: set ft=javascript: */
/*
 * Purpose   : Run hi_score lifecycle tools
 * Example   : See xhi help
 * Author    : Michael S. Mikowski - mike.mikowski@gmail.com
 *
*/
/*jslint node : true */
/*global Promise */
// == BEGIN SCRIPT xhi - the hi_score cli life-stage tool =============
  // == BEGIN MODULE SCOPE VARIABLES ==================================
  'use strict';
  var
    childProcObj = require( 'child_process' ),
    fsObj        = require( 'fs'            ),
    npmObj       = require( 'npm'           ),

    pathObj      = require( 'path'          ),
    readlineObj  = require( 'readline'      ),
    utilObj      = require( 'util'          ),

    makeSpawnObj  = childProcObj.spawn,
    PromiseObj    = Promise,

    // Convert to promises using promisfy
    promisifyFn   = utilObj.promisify,

    // Assign nodejs builtins
    // eventObj      = new EventEmitter(),
    fqAppFilename = __filename,
    fqBinDirname  = __dirname,

    // Get environment values
    appName       = pathObj.basename( fqAppFilename, '.js' ),
    argList       = process.argv,
    fqOrigDirname = process.cwd(), // or pathObj.resolve()
    padName       = '    ' + appName,
    promptStr     = appName + '> ',
    versList      = process.versions.node.split('.'),

    // Set paths
    fqProjDirname   = pathObj.dirname( fqBinDirname ),

    fqLibDirname    = fqProjDirname   + '/lib',
    fqModuleDirname = fqProjDirname   + '/node_modules',
    fqPkgFilename   = fqProjDirname   + '/package.json',

    // Set minimum Node verion and init empty path map
    minVersionInt  = 8,
    binPathMap     = {},

    // Declare curried functions
    abortFn, exitFn, logFn, warnFn, makeTmpltStr,

    // Declare config data
    fqHookFilename,  pkgMatrix,    setupMatrix,
    commandTable,

    // Declare after-install-variables
    LineReader,    applyPatchFn,  exeCpeFn,
    flowObj,       mkdirpFn,      ncpFn,
    psObj,         rmDirFn,       shellJsObj,
    whichFn,       writeFn,

    makeWhichProm
    ;
  // == . END MODULE SCOPE VARIABLES ==================================

  // == BEGIN UTILITY METHODS =========================================


  // BEGIN utility /readPkgFileFn/
  // Purpose:
  function readPkgFileFn ( on_read_fn ) {
    fsObj.readFile( fqPkgFilename, 'utf8', on_read_fn );
  }
  // . END utility /readPkgFileFn/

  // BEGIN utility /writePkgFileFn/
  // write-file-atomic for safety!
  function writePkgFileFn ( on_write_fn ) {
    var package_str = JSON.stringify( pkgMatrix, null, '  ' );
    writeFn(
      fqPkgFilename, package_str, on_write_fn
    );
  }
  // . END utility /writePkgFileFn/


  // BEGIN utility /makeTmpltStr/
  // See js/xhi/01.util.js
  makeTmpltStr = (function () {
    function lookupFn ( ignore_str, lookup_name ) {
      var
        lookup_map   = this,
        lookup_list  = lookup_name.split( '.' ),
        lookup_count = lookup_list.length,
        idx, key_name
      ;

      for ( idx = 0; idx < lookup_count; idx++ ) {
        key_name = lookup_list[ idx ];
        lookup_map = ( lookup_map && lookup_map[ key_name ] );
      }
      return String( lookup_map ) || '';
    }

    function mainFn ( arg_map ) {
      // noinspection Annotator
      var
        map        = arg_map || {},
        input_str  = map._input_str_  || '',
        lookup_map = map._lookup_map_ || {},

        tmplt_rx   = /\{\{([^}]*[^}]+[^}]*)\}\}/g,
        bound_fn   = lookupFn.bind( lookup_map )
      ;

      return input_str.replace( tmplt_rx, bound_fn );
    }
    return mainFn;
  }());
  // . END utility /makeTmpltStr/


  // BEGIN utility /makeRightPadStr/
  function makeRightPadStr ( arg_str, arg_count ) {
    var
      delta_count = arg_count - arg_str.length,
      delta_list  = []
      ;

    delta_list.length = delta_count > 0 ? delta_count : 0;
    return arg_str + delta_list.join(' ');
  }
  // . END utility /makeRightPadStr/

  // BEGIN utility /_outFn/
  // Purpose: provides abortFn, exitFn, logFn, and warnFn
  function _outFn() {
    var
      ctx_obj    = this || {},
      method_str = ctx_obj.method_str || 'log',
      prompt_str = ctx_obj.prompt_str || promptStr,
      arg_list   = Array.from( arguments )
      ;

    if ( arg_list.length > 0 ) {
      arg_list.unshift( prompt_str );
      console[ method_str ].apply( null, arg_list );
    }
    if ( ctx_obj.cd_name ) {
      process.chdir( ctx_obj.cd_name );
    }
    if ( ctx_obj.do_abort ) { process.exit( 1 ); }
    if ( ctx_obj.do_exit  ) { process.exit( 0 ); }
  }
  abortFn = _outFn.bind({
    cd_name      : fqOrigDirname,
    do_abort     : true,
    method_str : 'warn',
    prompt_str : appName + '-abort> '
  });
  exitFn = _outFn.bind({
    cd_name   : fqOrigDirname,
    do_exit    : true,
    prompt_str : appName + '-exit> '
  });
  logFn   = _outFn.bind({});
  warnFn  = _outFn.bind({
    method_str : 'warn',
    prompt_str : appName + '-warn> '
  });
  // . END utility /_outFn/

  // BEGIN utility /askFn/
  // Purpose: Wrap readObj question with prompt
  //
  function askFn ( ask_str, response_fn ) {
    var read_obj = readlineObj.createInterface({
      input  : process.stdin,
      output : process.stdout
    });

    read_obj.question(
      promptStr + ask_str,
      function ( str ) {
        read_obj.close();   // Relinquish readline control of stdio
        response_fn( str );
      }
    );
  }
  // . END utilities /askFn/

  // BEGIN utility /makeCommandTable/
  // Purpose: Create data structure to look up command details
  //
  function makeCommandTable ( raw_table ) {
    var
      head_list   = raw_table[ 0 ],
      head_count  = head_list.length,
      prefix_str  = '\n' + promptStr + '   ',
      solve_table = [],
      raw_count   = raw_table.length,

      idx, row_list, solve_id, solve_map,
      jdx, field_key, field_data, solve_str
      ;

    for ( idx = 1; idx < raw_count; idx++ ) {
      row_list = raw_table[ idx ];
      solve_id   = String( idx - 1 );
      if ( solve_id.length < 2 ) { solve_id = '0' + solve_id; }
      solve_map = { id : solve_id, idx : idx - 1  };

      FIELD: for ( jdx = 0; jdx < head_count; jdx++ ) {
        field_key  = head_list[ jdx ];
        field_data = row_list[  jdx ];
        if ( field_key.match( /_str$/ ) ) {

          // Join array into multi-line string
          if ( Array.isArray( field_data ) ) {
            solve_str = prefix_str + field_data.join( prefix_str );
          }
          else {
            solve_str = String( field_data );
          }

          // Template replace
          solve_str = makeTmpltStr( {
            _input_str_  : solve_str,
            _lookup_map_ : {
              appName : appName,
              padName : padName
            }
          } );
          solve_map[ field_key ] = solve_str;
          continue FIELD;
        }
        solve_map[ field_key ] = field_data;
      }
      solve_table.push( solve_map );
    }
    return solve_table;
  }
  // . END utility /makeCommandTable/

  // BEGIN utility /filterByAlias/
  function filterByAlias ( map ) {
    return ( map.alias_list.indexOf( this ) > -1 );
  }
  // . END utility /filterByAlias/

  // BEGIN utility /getCommandMap/
  function getCommandMap ( row_id ) {
    var
      idx = parseInt( row_id, 10 ),
      filter_list
      ;

    if ( isNaN( idx ) ) {
      filter_list = commandTable.filter( filterByAlias, row_id );
    }
    else {
      filter_list = [ commandTable[ idx ] ];
    }
    return filter_list[ 0 ];
  }
  // . END utility /getCommandMap/

  // BEGIN utility /makePrefixStr/
  function makePrefixStr ( command_map ) {
    // noinspection MagicNumberJS
    return 'Stage ' + command_map.id + ' '
      + makeRightPadStr( command_map.alias_list[ 0 ], 12 ) + ': '
      ;
  }
  // . END utility /makePrefixStr/

  // BEGIN utility /makeParamMap/
  // Purpose   : Process command line arguments
  // Example   : makeParamMap( [ 'help', '1', '-v' ] )
  //   returns : { do_verbose: true, range_str : '1',
  //               stage_list : [ <commandRowHelp> ] }
  // Example   : makeParamMap( [ '1', '-v' ] )
  //   returns : { do_verbose: true, range_str : '1'
  //               stage_list : [ <commandRow1> ] }
  // Arguments : (positional)
  //   0) stage_list - list of command line arguments and switches
  //   1) skip_idx   - skip this number of arguments (not switches)
  // Returns   :  An object as follows:
  //   { do_verbose : <true|false>,
  //     range_str  : <cli_range_provided>,
  //     stage_list : [  <commandRow0>, <commandTableRow1, ...  ]
  //   }
  function makeParamMap ( param_list, arg_skip_idx ) {
    var
      arg_count  = 0,
      skip_idx   = arg_skip_idx || 0,

      do_verbose = false,
      range_str  = '',
      stage_list = null,

      edge_list, temp_list
      ;

    param_list.forEach( function ( str, ignore_idx ) {
      var i, first_map, middle_map, last_map, first_idx, last_idx;
      if ( str === '-v' ) {
        do_verbose = true;
        return;
      }

      // skip range list if already defined
      if ( stage_list ) { return true; }

      if ( str.match(/-/) || str === 'all' ) {
        if ( arg_count < skip_idx ) {
          arg_count++;
          return;
        }

        edge_list = str === 'all'
          ? [ 0, commandTable.length - 1 ]
          : str.split( '-', 2 );

        first_map = getCommandMap( edge_list[ 0 ] );
        last_map  = getCommandMap( edge_list[ 1 ] );
        if ( ! first_map ) {
          return warnFn( 'Range stage ' + edge_list[ 0 ] + ' is invalid' );
        }
        if ( ! last_map ) {
          return warnFn( 'Range stage ' + edge_list[ 1 ] + ' is invalid' );
        }
        if ( first_map.idx > last_map.idx ) {
          return warnFn(
            'Range start start ' + edge_list[ 0 ]
            + ' exceeds stage end ' + edge_list[ 1 ]
          );
        }

        temp_list = [ first_map ];

        first_idx = first_map.idx + 1;
        last_idx  = last_map.idx  - 1;

        for ( i = first_idx; i <= last_idx; i++ ) {
          middle_map = getCommandMap( i );
          if ( ! middle_map ) { return; }
          temp_list.push( middle_map );
        }
        if ( last_map !== first_map ) {
          temp_list.push( last_map );
        }

        range_str  = str;
        stage_list = temp_list;
        return;
      }

      if ( str.match(/,/) ) {
        if ( arg_count < skip_idx ) {
          arg_count++;
          return;
        }
        edge_list = str.split(',');
        temp_list = [];
        edge_list.forEach( function ( data, ignore_idx ) {
          middle_map = getCommandMap( data );
          if ( ! middle_map ) { return; }
          temp_list.push( middle_map );
        });

        range_str  = str;
        stage_list = temp_list;
        return;
      }

      if ( arg_count < skip_idx ) {
        arg_count++;
        return;
      }
      middle_map = getCommandMap( str );
      if ( ! middle_map ) { return; }

      range_str  = str;
      stage_list = [ middle_map ];
    });

    return {
      do_verbose : do_verbose,
      range_str  : range_str,
      stage_list : stage_list || []
    };
  }
  // . END utility /makeParamMap/

  // BEGIN utlity /grepFileFn/
  // Purpose : Return list of lines in a file that match a pattern
  function grepFileFn ( filename, pattern_str ) {
    return new PromiseObj ( function ( resolve_fn, catch_fn ) {
      var
        line_read_obj = new LineReader( filename, {skipEmptyLines:true }),
        pattern_rx    = new RegExp( pattern_str ),
        match_list    = []
        ;

      line_read_obj.on( 'error', catch_fn );
      line_read_obj.on( 'line',  function ( line_str ) {
        if ( line_str.match( pattern_rx ) ) {
          match_list.push( line_str );
        }
      });
      line_read_obj.on( 'end', function () {
        resolve_fn( match_list );
      });
    });
  }
  // . END utility /grepFileFn/

  // BEGIN utility /copyPathFn/
  function copyPathFn( fq_src_path_str, fq_dest_path_str, do_dir_copy ) {
    if ( do_dir_copy ) {
      return new PromiseObj ( function ( resolve_fn, reject_fn ) {
        ncpFn( fq_src_path_str, fq_dest_path_str,
          function ( error_data ) {
            if ( error_data ) { return reject_fn(); }
            resolve_fn();
          }
        );
      });
    }

    return new PromiseObj ( function ( resolve_fn, reject_fn ) {
      var
        read_obj = fsObj.createReadStream(  fq_src_path_str  ),
        write_obj= fsObj.createWriteStream( fq_dest_path_str );

      read_obj.on(  'error', reject_fn  );
      write_obj.on( 'error', reject_fn  );
      write_obj.on( 'close', resolve_fn );
      read_obj.pipe( write_obj );
    });
  }
  // . END utility /copyPathFn/

  // BEGIN utility /storePathFn/
  function storePathFn ( path_str ) {
    var
      ctx_obj = this,
      bin_key = ctx_obj.bin_key;

    if ( ! bin_key ) {
      abortFn( 'No key provided for ' + path_str );
    }
    binPathMap[ bin_key ]  = path_str;
  }
  // . END utility /storePathFn/

  // BEGIN utility /loadPostInstallfn/
  // Loads libraries after stage 01 (install) is complete
  function loadLibsFn () {
    LineReader   = require( 'line-by-line'      );
    applyPatchFn = require( 'apply-patch'       ).applyPatch;
    exeCpeFn     = require( 'execpe'            );
    flowObj      = require( 'flow'              );
    mkdirpFn     = require( 'mkdirp'            );
    ncpFn        = require( 'ncp'               ).ncp;
    psObj        = require( 'ps-node'           );
    rmDirFn      = require( 'rmdir'             );
    shellJsObj   = require( 'shelljs'           );
    whichFn      = require( 'which'             );
    writeFn      = require( 'write-file-atomic' );

    makeWhichProm = promisifyFn( whichFn );
  }
  // . END utility /loadLibsFn/

  // BEGIN utility /checkBinListFn/
  function checkBinListFn () {
    var
      ctx_obj      = this,
      exe_list     = [ 'git', 'patch' ],
      exe_count    = exe_list.length,
      promise_list = [],

      idx, bin_key, bound_fn, promise_obj;

    // Assign executable path vars
    for ( idx = 0; idx < exe_count; idx++ ) {
      bin_key     = exe_list[ idx ];
      bound_fn    = storePathFn.bind( { bin_key : bin_key });
      promise_obj = makeWhichProm( bin_key );
      promise_obj.then( bound_fn ).catch( abortFn );
      promise_list.push( promise_obj );
    }

    PromiseObj.all( promise_list )
      .then(  ctx_obj.then_fn  )
      .catch( ctx_obj.catch_fn )
      ;
  }
  // . END utility /checkBinListFn/

  // BEGIN utility /checkNodeVersionFn/
  function checkNodeVersionFn () {
    var abort_str;
    if ( Number( versList[0] ) < minVersionInt ) {
      abort_str
        = 'NodeJS Version ' + versList.join('.') + ' is installed.\n'
        + 'As of ' + appName + '1.2 NodeJS v'
        + minVersionInt + ' is required.\n'
        + 'Please upgrade NodeJS and try again.'
        ;
      abortFn( abort_str );
    }
  }
  // . END utility /checkNodeVersionFn/

  // BEGIN utility /storePkgMapFn/
  function storePkgMapFn ( error_obj, json_str ) {
    var ctx_obj = this;
    if ( error_obj ) { return ctx_obj.catch_fn( error_obj ); }
    pkgMatrix   = JSON.parse( json_str ) || {};
    setupMatrix = pkgMatrix.xhi_02_SetupMatrix;
    ctx_obj.then_fn();
  }
  // . END utility /storePkgMapFn/

  // BEGIN utility /copyVendorFilesFn/
  // TODO mmikowski 2017-08-18: move this to xhi_02
  function copyVendorFilesFn () {
    var
      ctx_obj            = this,
      asset_group_table  = setupMatrix.asset_group_table || [],
      dev_dependency_map = pkgMatrix.devDependencies     || {},
      asset_group_count  = asset_group_table.length,
      promise_list       = [],

      idx, asset_group_map, asset_list, asset_count,
      fq_dest_dir_str, dest_ext_str, do_dir_copy,

      idj, asset_map, src_asset_name, src_dir_str,
      src_pkg_name, dest_vers_str, dest_name,
      fq_src_path_list, fq_src_path_str,
      fq_dest_path_str, promise_obj
      ;

    for ( idx = 0; idx < asset_group_count; idx++ ) {
      asset_group_map = asset_group_table[ idx ] || {};

      asset_list  = asset_group_map.asset_list   || [];
      asset_count = asset_list.length;

      dest_ext_str     = asset_group_map.dest_ext_str;
      do_dir_copy      = asset_group_map.do_dir_copy;
      fq_dest_dir_str  = fqProjDirname + '/'
        + asset_group_map.dest_dir_str;

      mkdirpFn.sync( fq_dest_dir_str );
      ASSET_MAP: for ( idj = 0; idj < asset_count; idj++ ) {
        asset_map      = asset_list[ idj ];
        src_asset_name = asset_map.src_asset_name;
        src_dir_str    = asset_map.src_dir_str || '';
        src_pkg_name   = asset_map.src_pkg_name;

        dest_vers_str  = dev_dependency_map[ src_pkg_name ];

        if ( ! dest_vers_str ) {
          logFn( 'WARN: package ' + src_pkg_name + ' not found.');
          continue ASSET_MAP;
        }
        dest_name = asset_map.dest_name || src_pkg_name;

        fq_dest_path_str = fq_dest_dir_str
          + '/' + dest_name + '-' + dest_vers_str;
        fq_src_path_list = [ fqModuleDirname, src_pkg_name, src_asset_name ];
        if ( src_dir_str ) { fq_src_path_list.splice( 2, 0, src_dir_str ); }

        fq_src_path_str = fq_src_path_list.join( '/' );

        if ( ! do_dir_copy ) {
          fq_dest_path_str += '.' + dest_ext_str;
        }
        promise_obj = copyPathFn(
          fq_src_path_str, fq_dest_path_str, do_dir_copy
        );
        promise_list.push( promise_obj );
      }
    }

    PromiseObj.all( promise_list )
      .then(  ctx_obj.then_fn  ).catch( ctx_obj.catch_fn );
  }
  // . END utility /copyVendorFilesFn/

  // BEGIN utility /unlinkHookFn/
  // TODO mmikowski 2017-08-18: move this to xhi_02
  // This ignores any error
  function unlinkHookFn () {
    var ctx_obj = this;
    fqHookFilename = fqProjDirname + '/.git/hooks/pre-commit';
    fsObj.unlink( fqHookFilename, ctx_obj.then_fn );
  }
  // . END utility /unlinkHookFn/

  // BEGIN utility /linkHookFn/
  // This function requires CWD to be fqProjDirname
  // TODO mmikowski 2017-08-18: move this to xhi_02
  function linkHookFn () {
    var ctx_obj = this;
    fsObj.symlink(
      '../../bin/git-hook_pre-commit',
      fqHookFilename,
      function ( error_data ) {
        if ( error_data ) { abortFn( error_data ); }
        ctx_obj.then_fn();
      }
    );
  }
  // . END utility /linkHookFn/
  // == END UTILITY METHODS ============================================

  // == BEGIN EVENT HANDLERS ===========================================
  // function makeBoundEmitFn ( signal_str ) {
  //   return function () { eventObj.emit( signal_str ); };
  // }
  // == . END EVENT HANDLERS ==========================================

  // BEGIN utility /makePostObj/
  // Purpose: Creates resource map for modules available
  //   only after npm install.
  //
  function makePostObj () {
    return {
      applyPatchFn      : applyPatchFn,
      binPathMap        : binPathMap,        // --  ?
      checkBinListFn    : checkBinListFn,    // 02 setup
      copyVendorFilesFn : copyVendorFilesFn, // 02 setup
      exeCpeFn          : exeCpeFn,          // --  ?
      flowObj           : flowObj,           // 02 setup
      grepFileFn        : grepFileFn,        // 02 setup, 06 lint
      linkHookFn        : linkHookFn,        // 02 setup
      psObj             : psObj,             // 06 dev_start
      rmDirFn           : rmDirFn,           // 02 setup
      shellJsObj        : shellJsObj,        // 11 build
      unlinkHookFn      : unlinkHookFn,      // 02 setup
      writePkgFileFn    : writePkgFileFn     // 05 upgrade
    };
  }
  // . END utility /makePostObj/


  // BEGIN utility /makeXhiObj/
  // Purpose: Create object to provide as context to lib functions
  //  nextFn and catchFn are defaults.
  //
  function makeXhiObj () {
    return {
      appName         : appName,        // Applicaiton name
      askFn           : askFn,          // Read line with prompt
      catchFn         : abortFn,        // Fn for error
      childProcObj    : childProcObj,   // child_process object
      commandMap      : null,           // Command map of lib to exec
      fqBinDirname    : fqBinDirname,   // Full path of bin scripts
      fqModuleDirname : fqModuleDirname,   // Full path to node modules
      fqOrigDirname   : fqOrigDirname,  // Full path of PWD
      fqPkgFilename   : fqPkgFilename,  // Full path to package.json
      fqProjDirname   : fqProjDirname,  // Full path of root project dir
      fsObj           : fsObj,          // File system object
      getCommandMap   : getCommandMap,  // Get command map by id or index
      loadLibsFn      : loadLibsFn,     // Load libs after stage 1
      logFn           : logFn,          // Log to console
      makePrefixStr   : makePrefixStr,  // Fn for stage prefix
      makeRightPadStr : makeRightPadStr,// Pad string right
      makeSpawnObj    : makeSpawnObj,   // Object create spawned proc
      makePostObj     : makePostObj,     // Get utils after stage 1
      nextFn          : exitFn,         // Fn for success
      npmObj          : npmObj,         // Npm API object
      paramMap        : null,           // Parameters per CLI input
      PromiseObj      : PromiseObj,     // Promise object
      promisifyFn     : promisifyFn,    // Promisify from utils
      pkgMatrix       : pkgMatrix,      // package.json content
      warnFn          : warnFn          // Warn to console
    };
  }
  // . END utility /makeXhiObj/

  // == BEGIN PUBLIC METHOD /mainFn/ ==================================
  // Purpose   : Parse command line and dispatch to requested command(s)
  function mainFn () {
    var
      param_list        = argList.slice( 2 ),
      exec_list         = [],
      range_start_str   = '',
      range_success_str = '',
      stage_idx         = 0,

      param_map,   stage_list,  command_map,
      xhi_obj,     stage_fn,    stage_count,
      predo_list,  predo_count, predo_idx,
      prefix_str,  bound_fn
      ;

    // Create command table from config
    commandTable = makeCommandTable( pkgMatrix.xhi_commandTable );

    // Abort if node version < minVersionInt
    checkNodeVersionFn();

    param_map    = makeParamMap( param_list ); // cli parameters
    stage_list   = param_map.stage_list;       // stage list from range
    command_map  = stage_list[ 0 ];            // first stage
    xhi_obj      = makeXhiObj();               // context obj for libs

    // Begin run in help mode
    if ( ! command_map
      || param_map.range_str === ''
      || param_map.range_str.match(/^0+$/)
      || param_map.range_str === 'help'
    ) {
      command_map = getCommandMap( 0 );
      xhi_obj.commandMap = command_map;
      xhi_obj.paramMap   = makeParamMap( param_list, 1 );
      xhi_obj.doListShow = true;
      stage_fn = require( fqLibDirname + '/xhi_00.js' );
      return stage_fn.call( xhi_obj );
    }
    // . End run in help mode

    // Begin expand stage list to resolve all predo_list and preq_lists
    //   dependencies then sort in-order.
    // predo_list   : List of steps that must be added to the command list
    //   IFF they are not already in the range provided
    // prereq_list : List of stages that must have been performed at some
    //   any time after install.
    //
    stage_count = stage_list.length;
    while ( stage_idx < stage_count ) {
      predo_list  = command_map.predo_list || [];
      predo_count = predo_list.length;
      for ( predo_idx = 0; predo_idx < predo_count; predo_idx++ ) {
        command_map = getCommandMap( predo_list[ predo_idx ] );
        if ( stage_list.indexOf( command_map ) === -1 ) {
          stage_list.push( command_map );
          stage_count++;
        }
      }
      stage_idx++;
    }
    stage_list.sort( function ( a, b ) { return a.idx > b.idx; } );
    // END expand stage list

    // Begin run stage list
    // Walk backward through list and bind functions.
    // The last function should have nextFn set to exit function,
    //   the second-to-last function should have nextFn set to
    //   the last function; the third-to-last function should have
    //   nextFn/ set to the second-to-last function, and so on.
    //
    if ( stage_list.length > 1 ) {
      prefix_str  = 'Process range ' + param_map.range_str;
      range_start_str   = prefix_str + ' Start';
      range_success_str = prefix_str + ' Success';
    }

    xhi_obj.nextFn = function _nextFn () {
      exitFn( range_success_str );
    };

    stage_idx = stage_list.length - 1;
    while ( stage_idx > -1 ) {
      // Set commandMap, paramMap in context object
      command_map        = stage_list[ stage_idx ];
      xhi_obj.commandMap = command_map;
      xhi_obj.paramMap   = param_map;

      // Load library ( TODO load preq_list? )
      stage_fn = require( fqLibDirname + '/xhi_' + command_map.id + '.js' );

      // Build exec chain
      bound_fn = stage_fn.bind( xhi_obj );
      exec_list.push( bound_fn );

      // Make new context object and set catchFn, nextFn
      if ( stage_idx > 0 ) {
        xhi_obj        = makeXhiObj();
        xhi_obj.nextFn = bound_fn;
      }
      stage_idx--;
    }
    logFn( range_start_str );
    if ( bound_fn ) { return bound_fn(); }
    // . End run stage list
  }
  // == . END PUBLIC METHOD /mainFn/ ==================================

  // == BEGIN INITIALIZE SCRIPT =======================================
  readPkgFileFn( storePkgMapFn.bind({
      catch_fn : abortFn, then_fn : mainFn
    })
  );
  // == . END INITIALIZE SCRIPT =======================================
// == . END SCRIPT xhi - the hi_score cli life-stage tool =============
